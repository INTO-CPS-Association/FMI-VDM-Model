/**
 * Definitions that support a co-simulation setup.
 */
types
	FMUVariable ::
		fmuIndex	: nat1		-- Index into CoSimulation.fmus
		svIndex		: nat1;		-- Index into FMU.modelVariables

	ConnectionMap = map FMUVariable to set of FMUVariable;

	CoSimulation ::
		fmus		: seq1 of FMIModelDescription
		connections	: ConnectionMap		-- Outputs mapped to inputs
	inv cs ==
		isValidCoSimulation(cs.fmus, cs.connections);

functions
	/**
	 * The type invariant for CoSimulation.
	 */
	isValidCoSimulation: seq1 of FMIModelDescription * ConnectionMap +> bool
	isValidCoSimulation(fmus, connections) ==
		let maxFMU = len fmus in
			-- Inputs are valid
			(
				forall input in set dom connections &
					-- @OnFail("Illegal FMU index: %s", input.fmuIndex)
					( input.fmuIndex <= maxFMU )
					-- @OnFail("Illegal SV index: %s", input.svIndex)
					and ( input.svIndex < len fmus(input.fmuIndex).modelVariables )
					-- @OnFail("Variable for FMU %s, SV %s is not an input", input.fmuIndex, input.svIndex)
					and ( fmus(input.fmuIndex).modelVariables(input.svIndex).causality = <input>)
			)
			and
			-- Outputs are valid
			(
				forall output in set dunion rng connections &
					-- @OnFail("Illegal FMU index: %s", output.fmuIndex)
					( output.fmuIndex <= maxFMU )
					-- @OnFail("Illegal SV index: %s", output.svIndex)
					and ( output.svIndex < len fmus(output.fmuIndex).modelVariables )
					-- @OnFail("Variable for FMU %s, SV %s is not an input", output.fmuIndex, output.svIndex)
					and ( fmus(output.fmuIndex).modelVariables(output.svIndex).causality = <output>)
			)
			and
			-- Connections are inter-FMU, not intra-FMU
			(
				forall v1 in set dom connections &
					forall v2 in set connections(v1) &
						v1.fmuIndex <> v2.fmuIndex
			);

functions
	/**
	 * Given an FMU description and its CoSimulation index, produce a map of its internal
	 * connections - that is, its input-output dependencies.
	 */
	internalConnections: FMIModelDescription * nat1 -> ConnectionMap
	internalConnections(fmu, fmuIndex) ==
		is not yet specified
	post
		(forall v in set dom RESULT &
			v.fmuIndex = fmuIndex and v.svIndex <= len fmu.modelVariables)
		and
		(forall v in set dunion rng RESULT &
			v.fmuIndex = fmuIndex and v.svIndex <= len fmu.modelVariables);

	/**
	 * Given a CoSimulation and its full connectivity map, decide whether the CoSimulation
	 * has any algebraic loops.
	 */
	hasLoops: CoSimulation * ConnectionMap * set of FMUVariable * FMUVariable -> bool
	hasLoops(simulation, connectedTo, reached, active) ==
		if active not in set dom connectedTo
		then false	-- Reached the end of this path
		else
			forall next in set connectedTo(active) &
				next in set reached		-- A loop!
				or hasLoops(simulation, connectedTo, reached union {next}, next)
	measure is not yet specified;

