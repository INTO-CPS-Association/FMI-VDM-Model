/**
 * Definitions that support a co-simulation setup.
 */
types
	FMUVariable ::
		fmuIndex		: nat1		-- Index into CoSimulation.fmus
		svIndex			: nat1;		-- Index into FMU.modelVariables

	ConnectionMap = map FMUVariable to set of FMUVariable;

	CoSimulation ::
		fmus			: seq1 of FMIModelDescription
		connections		: ConnectionMap		-- Inter-FMU, outputs mapped to inputs
	inv cs ==
		isValidCoSimulation(cs.fmus, cs.connections);

functions
	/**
	 * The type invariant for CoSimulation.
	 */
	isValidCoSimulation: seq1 of FMIModelDescription * ConnectionMap +> bool
	isValidCoSimulation(fmus, connections) ==
		let maxFMU = len fmus in
			-- Inputs are valid
			(
				forall source in set dom connections &
					-- @OnFail("Illegal FMU index: %s", source.fmuIndex)
					( source.fmuIndex <= maxFMU )
					-- @OnFail("Illegal SV index: %s", source.svIndex)
					and ( source.svIndex < len fmus(source.fmuIndex).modelVariables )
					-- @OnFail("Source (FMU %s, SV %s) is not an output", source.fmuIndex, source.svIndex)
					and ( fmus(source.fmuIndex).modelVariables(source.svIndex).causality = <output>)
			)
			and
			-- Outputs are valid
			(
				forall dest in set dunion rng connections &
					-- @OnFail("Illegal FMU index: %s", dest.fmuIndex)
					( dest.fmuIndex <= maxFMU )
					-- @OnFail("Illegal SV index: %s", dest.svIndex)
					and ( dest.svIndex < len fmus(dest.fmuIndex).modelVariables )
					-- @OnFail("Destination (FMU %s, SV %s) is not an input", dest.fmuIndex, dest.svIndex)
					and ( fmus(dest.fmuIndex).modelVariables(dest.svIndex).causality = <input>)
			)
			and
			-- All connections are inter-FMU, not intra-FMU
			(
				forall v1 in set dom connections &
					forall v2 in set connections(v1) &
						v1.fmuIndex <> v2.fmuIndex
			)
			-- Inter-FMU connections are point to point, not 1:n or n:1
			and
			(
				card dunion { vs | vs in set rng connections } = card rng connections
				and
				forall vs in set rng connections & card vs = 1
			);

	/**
	 * Given an FMU description and its CoSimulation index, produce a map of its internal
	 * connections - that is, its input-output dependencies.
	 */
	fmuInternalConnections: FMIModelDescription * nat1 -> ConnectionMap
	fmuInternalConnections(fmu, fmuIndex) ==
		let ctvars = continuousTimeStates(fmu.modelVariables),

			allKnowns = [ i | i in set inds fmu.modelVariables &
				let sv = fmu.modelVariables(i) in
					sv.causality = <input> or sv in set ctvars ],

			eOutputs =
				if fmu.modelStructure.outputs = nil
				then []		-- No outputs??
				else
				[
					if output.dependencies = nil
					then mu(output, dependencies |-> allKnowns)		-- Nil dependencies means all knowns
					else output

					| output in seq fmu.modelStructure.outputs		-- Also derivatives? When initialUnknowns?
				]
		in
		{
			-- Each entry maps a source to all of the outputs that have the source as a dependency.
			mk_FMUVariable(fmuIndex, source) |->
				{ mk_FMUVariable(fmuIndex, output.index)
					| output in seq eOutputs
					& source in set elems output.dependencies }

			-- The set of sources (dependencies) of all the outputs.
			| source in set
				dunion { elems output.dependencies | output in seq eOutputs } 
		}
	post
		(forall v in set dom RESULT &
			v.fmuIndex = fmuIndex and v.svIndex <= len fmu.modelVariables)
		and
		(forall v in set dunion rng RESULT &
			v.fmuIndex = fmuIndex and v.svIndex <= len fmu.modelVariables);

	/**
	 * Given a CoSimulation and its full connectivity map, decide whether the CoSimulation
	 * has any algebraic loops.
	 */
	hasLoops2: ConnectionMap * set of FMUVariable * FMUVariable -> bool
	hasLoops2(fullMap, reached, active) ==
		if active not in set dom fullMap
		then false	-- Reached the end of this path
		else
			forall next in set fullMap(active) &
				next in set reached		-- A loop! Test for a fixed-point in the reached set here?
				or hasLoops2(fullMap, reached union {next}, next)
	measure is not yet specified;

	/**
	 * Construct the full connection map for a CoSimulation and check for loops.
	 */
	hasLoops: CoSimulation +> bool
	hasLoops(cosim) ==
		let fullMap = merge { fmuInternalConnections(cosim.fmus(i), i) | i in set inds cosim.fmus },
			starts = { v | v in set dom cosim.connections }
		in
			exists input in set starts &
				hasLoops2(fullMap, {}, input);
