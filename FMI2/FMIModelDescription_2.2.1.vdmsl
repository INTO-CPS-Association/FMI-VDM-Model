/**
 * This file is part of the INTO-CPS toolchain.
 *
 * Copyright (c) 2017-2019, INTO-CPS Association,
 * c/o Professor Peter Gorm Larsen, Department of Engineering
 * Finlandsgade 22, 8200 Aarhus N.
 *
 * All rights reserved.
 *
 * THIS PROGRAM IS PROVIDED UNDER THE TERMS OF GPL VERSION 3 LICENSE OR
 * THIS INTO-CPS ASSOCIATION PUBLIC LICENSE VERSION 1.0.
 * ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS PROGRAM CONSTITUTES
 * RECIPIENT'S ACCEPTANCE OF THE OSMC PUBLIC LICENSE OR THE GPL 
 * VERSION 3, ACCORDING TO RECIPIENTS CHOICE.
 *
 * The INTO-CPS toolchain  and the INTO-CPS Association Public License are
 * obtained from the INTO-CPS Association, either from the above address, from
 * the URLs: http://www.into-cps.org, and in the INTO-CPS toolchain distribution.
 * GNU version 3 is obtained from: http://www.gnu.org/copyleft/gpl.html.
 *
 * This program is distributed WITHOUT ANY WARRANTY; without
 * even the implied warranty of  MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE, EXCEPT AS EXPRESSLY SET FORTH IN THE
 * BY RECIPIENT SELECTED SUBSIDIARY LICENSE CONDITIONS OF
 * THE INTO-CPS ASSOCIATION.
 *
 * See the full INTO-CPS Association Public License conditions for more details.
 */

/**
 * 2.2.1 Definition of an FMU (fmiModelDescription)
 */
types
	ModelAttributes ::
		location					: Location
		fmiVersion					: NormalizedString1
		modelName					: AnyString
		guid						: NormalizedString1
		description					: [AnyString]
		author						: [AnyString]
		version						: [NormalizedString1]
		copyright					: [AnyString]
		license						: [AnyString]
		generationTool				: [NormalizedString1]
		generationDateAndTime		: [AnyString]
		variableNamingConvention	: [<flat> | <structured>]
		numberOfEventIndicators		: [nat];


	-- XSD definition in section 2.2.1, p25
	FMIModelDescription ::
		-- The common model attributes
		attributes			: ModelAttributes			-- XSD 2.2.1, p31

		-- ModelExchange
		modelExchange		: [ModelExchange]			-- XSD 3.3.1, p89

		-- CoSimulation
		coSimulation		: [CoSimulation ]			-- XSD 4.3.1, p109

		-- Unit Definitions that are utilized in "ModelVariables"
		unitDefinitions		: [seq1 of Unit]			-- XSD 2.2.2, p33

		-- A global list of type definitions that are utilized in "ModelVariables"
		typeDefinitions		: [set1 of SimpleType]		-- XSD 2.2.3, p38

		-- Log categories
		logCategories		: [seq1 of Category]		-- XSD 2.2.4, p42

		-- Default experiment
		defaultExperiment	: [DefaultExperiment]		-- XSD 2.2.5, p43

		-- Vendor annotations
		vendorAnnotations	: [seq1 of Tool]			-- XSD 2.2.6, p43

		-- The central FMU data structure defining all variables of the FMU that
		-- Are visible/accessible via the FMU functions.
		modelVariables		: seq1 of ScalarVariable	-- XSD 2.2.7, p44

		-- Defines the structure of the model. Especially, the ordered lists of
		-- outputs, continuous-time states and initial unknowns (the unknowns
		-- during Initialization Mode) are defined here. Furthermore, the
		-- dependency of the unknowns from the knowns can be optionally
		-- defined.
		modelStructure		: ModelStructure;			-- XSD 2.2.8, p56

functions
	/**
	 * Valid description attributes.
	 */
	isValidModelAttributes: ModelAttributes +> bool
	isValidModelAttributes(attrs) ==
		-- @OnFail("2.2.1 ModelAttribute fmiVersion should be 2.0")
		( attrs.fmiVersion in set { "2.0" } );

	/**
	 * Invariant definition for FMIModelDescription
	 */
	isValidFMIModelDescription: FMIModelDescription +> bool
	isValidFMIModelDescription(md) ==
		-- First fill in effective values for model variables' missing attributes
		let eModelVariables =
			[ effectiveScalarVariable(sv) | sv in seq md.modelVariables ]
		in
		{
			-- @OnFail("2.2.1 ModelAttributes invalid at line %s", md.attributes.location)
			( isValidModelAttributes(md.attributes) ),

			-- @OnFail("2.2.1 ModelExchange invalid at line %s", md.modelExchange.location)
			( isValidModelExchange(md.modelExchange) ),

			-- @OnFail("2.2.1 CoSimulation invalid at line %s", md.coSimulation.location)
			( isValidCoSimulation(md.coSimulation) ),

			-- @OnFail("2.2.1 UnitDefinitions invalid"))
			( isValidUnitDefinitions(md.unitDefinitions) ),

			-- @OnFail("2.2.1 TypeDefinitions invalid")
			( isValidTypeDefinitions(md.typeDefinitions) ),

			-- @OnFail("2.2.1 LogCategories invalid")
			( isValidLogCategories(md.logCategories) ),

			-- @OnFail("2.2.1 DefaultExperiment invalid at line %s", md.defaultExperiment.location)
			( isValidDefaultExperiment(md.defaultExperiment) ),

			-- @OnFail("2.2.1 VendorAnnotations invalid")
			( isValidVendorAnnotations(md.vendorAnnotations) ),

			-- @OnFail("2.2.1 ScalarVariables invalid")
			( isValidScalarVariables(eModelVariables) ),

			-- @OnFail("2.2.1 ScalarVariables typecheck against TypeDefinitions failed")
			( typeCheck(eModelVariables, md.typeDefinitions) ),

			-- @OnFail("2.2.1 ModelStructure invalid at line %s", md.modelStructure.location)
			( isValidModelStructure(md.modelStructure) ),

			-- @OnFail("2.2.1 Neither ModelExchange nor CoSimulation specified")
			( md.modelExchange <> nil or md.coSimulation <> nil ),

			(
				md.typeDefinitions <> nil =>
					forall simpleType in set md.typeDefinitions &
						/* @OnFail("2.2.3 TypeDefinition and ScalarVariable names overlap: %s at line %s",
								simpleType.name, simpleType.location) */
						( not exists sv in seq eModelVariables & sv.name = simpleType.name )
			),


			(
				forall sv in seq eModelVariables &
					sv.canHandleMultipleSetPerTimeInstant <> nil =>
						/* @OnFail("2.2.7 [%s].canHandleMultipleSetPerTimeInstant invalid at line %s",
							sv.name, sv.location) */
						( md.modelExchange <> nil and sv.causality = <input> )
			),

			(
				let outputIndexes = { svi | svi in set inds eModelVariables &
					eModelVariables(svi).causality = <output> }
				in
				 	if outputIndexes <> {}
				 	then
						/* @OnFail("2.2.8 Outputs should be %s at line %s",
							outputIndexes, md.modelStructure.location) */
				 		( md.modelStructure.outputs <> nil
				 		  and { u.index | u in seq md.modelStructure.outputs } = outputIndexes )
				 	else
				 		/* @OnFail("2.2.8 Outputs should be omitted at line %s",
				 			md.modelStructure.location) */
				 		( md.modelStructure.outputs = nil )
			),

			(
				let derivativeIndexes = { svi | svi in set inds eModelVariables &
					is_Real(eModelVariables(svi).variable)
					and eModelVariables(svi).variable.derivative <> nil }
				in
				 	if derivativeIndexes <> {}
				 	then
				 		/* @OnFail("2.2.8 Real/derivative variables but no Derivatives declared at line %s",
				 			md.modelStructure.location) */
						( md.modelStructure.derivatives <> nil )

				 		and let structIndexes = { u.index | u in seq md.modelStructure.derivatives } in
				 		{
				 			/* @OnFail("2.2.8 Derivatives section does not match Real/derivative variables at line %s",
								md.modelStructure.location) */
							( structIndexes = derivativeIndexes ),

							/* @OnFail("2.2.8 Derivatives indexes out of range at line %s",
								md.modelStructure.location) */
				 			( forall i in set structIndexes & i <= len eModelVariables )
				 		} = {true}
				 	else
				 		/* @OnFail("2.2.8 Derivatives declared, but no Real/derivative variables at line %s",
				 			md.modelStructure.location) */
				 		( md.modelStructure.derivatives = nil )
			),

			-- InitalUnknowns must include all output (approx/calculated), calculatedParameters and 
			-- all continuous-time states and derivatives that are approx/calculated.
			-- And the list must be in ascending index order
			(
				let ctVars = continuousTimeStates(eModelVariables),
					sdVars = stateDerivatives(eModelVariables),
					initIndexes = { svi | svi in set inds eModelVariables &
						let sv = eModelVariables(svi) in
							(sv.causality = <output>
								and sv.initial in set { <approx>, <calculated> })

							or (sv.causality = <calculatedParameter>)

							or (sv in set ctVars
								and sv.initial in set { <approx>, <calculated> })

							or (sv in set sdVars
								and sv.initial in set { <approx>, <calculated> }) }
				in
				 	initIndexes <> {} =>
				 		let ius = md.modelStructure.initialUnknowns in
				 		{
			 				-- @OnFail("2.2.8 InitialUnknowns must include: %s", initIndexes)
			 				( ius <> nil ),

			 				-- @OnFail("2.2.8 InitialUnknowns must include: %s", initIndexes)
			 				( ius <> nil => { u.index | u in seq ius } subset initIndexes ),

			 				-- @OnFail("2.2.8 InitialUnknowns are not sorted: %s", [ u.index | u in seq ius ])
			 				( ius <> nil => 
					 				forall i in set inds ius &
					 					i = len ius or ius(i).index < ius(i+1).index )
				 		} = {true}
			)
		} = {true};

	/**
	 * Check that all variables' declaredTypes are defined, that the variables' types match
	 * the declared types and the min/max of numeric types are compatible with the start value.
	 */
	typeCheck: seq1 of ScalarVariable * [set1 of SimpleType] +> bool
	typeCheck(variables, typedefs) ==
		{
			let dname = sv.variable.declaredType in
				dname <> nil =>
					let matchingTypes = { td | td in set nilSet[SimpleType](typedefs) & td.name = dname } in
					{
						/* @OnFail("2.2.3 Typedefs have multiple matching names: %s",
							{ st.name | st in set matchingTypes } ) */
						( card matchingTypes = 1 ),

						-- The match is the same type as the ScalarVariable type and for numerics,
						-- and any start value is within the (perhaps overridden) min/max. 
						card matchingTypes = 1 => let { simpleType } = matchingTypes in
							cases simpleType.type:
								mk_RealType(dmin, dmax, -, -) ->
								{
									/* @OnFail("2.2.7 ScalarVariable %s, RealType not referenced by Real variable %s at line %s",
										sv.name, sv.variable.declaredType, sv.location) */
									( is_Real(sv.variable) ),

									-- And any start value matches the calculated min/max
									(
										sv.variable.start <> nil =>
											let min = if sv.variable.min <> nil then sv.variable.min
													  else if dmin <> nil then dmin
													  else nil,
												max = if sv.variable.max <> nil then sv.variable.max
													  else if dmax <> nil then dmax
													  else nil
											in
												/* @OnFail("2.2.7 ScalarVariable %s, calculated min/max does not match start %s at line %s",
													sv.name, sv.variable.start, sv.location) */
												(
													(max <> nil and min <> nil => max >= min)
													and (min <> nil => min <= sv.variable.start)
													and	(max <> nil => max >= sv.variable.start)
												)
									)
								} = {true},

								mk_IntegerType(dmin, dmax) ->
								{
									/* @OnFail("2.2.7 ScalarVariable %s, IntegerType not referenced by Integer variable %s at line %s",
										sv.name, sv.variable.declaredType, sv.location) */
									( is_Integer(sv.variable) ),

									-- And any start value matches the calculated min/max
									(
										sv.variable.start <> nil =>
											let min = if sv.variable.min <> nil then sv.variable.min
													  else if dmin <> nil then dmin
													  else nil,
												max = if sv.variable.max <> nil then sv.variable.max
													  else if dmax <> nil then dmax
													  else nil
											in
												/* @OnFail("2.2.7 ScalarVariable %s, calculated min/max does not match start %s at line %s",
													sv.name, sv.variable.start, sv.location) */
												(
													(max <> nil and min <> nil => max >= min)
													and (min <> nil => min <= sv.variable.start)
													and	(max <> nil => max >= sv.variable.start)
												)
									)
								} = {true},

								mk_BooleanType() ->
									/* @OnFail("2.2.7 ScalarVariable %s, BooleanType not referenced by Boolean variable %s at line %s",
										sv.name, sv.variable.declaredType, sv.location) */
									( is_Boolean(sv.variable) ),

								mk_StringType() ->
									/* @OnFail("2.2.7 ScalarVariable %s, StringType not referenced by String variable %s at line %s",
										sv.name, sv.variable.declaredType, sv.location) */
									( is_String(sv.variable) ),

								mk_EnumerationType(-) ->
									/* @OnFail("2.2.7 ScalarVariable %s, EnumerationType not referenced by Enumeration variable %s at line %s",
										sv.name, sv.variable.declaredType, sv.location) */
									( is_Enumeration(sv.variable) )
							end
					} = {true}
			| sv in seq variables
		} = {true};
