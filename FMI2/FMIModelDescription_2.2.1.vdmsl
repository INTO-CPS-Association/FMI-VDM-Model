/**
 * 2.2.1 Definition of an FMU (fmiModelDescription)
 */
types
	-- XSD definition on p25
	FMIModelDescription ::
		-- A global list of type definitions that are utilized in "ModelVariables"
		typeDefinitions		: set of SimpleType			-- XSD p38

		-- The central FMU data structure defining all variables of the FMU that
		-- Are visible/accessible via the FMU functions.
		modelVariables		: seq of ScalarVariable		-- XSD p44

		-- Defines the structure of the model. Especially, the ordered lists of
		-- outputs, continuous-time states and initial unknowns (the unknowns
		-- during Initialization Mode) are defined here. Furthermore, the
		-- dependency of the unkowns from the knowns can be optionally
		-- defined.
		modelStructure		: ModelStructure			-- XSD p56

	inv m ==
		isValidModelDescription(m.typeDefinitions, m.modelVariables, m.modelStructure);

functions
	/**
	 * Invariant definition for FMIModelDescription
	 */
	isValidModelDescription: set of SimpleType * seq of ScalarVariable * ModelStructure +> bool
	isValidModelDescription(typeDefinitions, modelVariables, modelStructure) ==
		-- Type definitions are unique by name
		card { t.name | t in set typeDefinitions } = card typeDefinitions

		-- All modelStructure variables must be declared in modelVariables
		and checkIndexes(len modelVariables, modelStructure.outputs)
		and checkIndexes(len modelVariables, modelStructure.derivatives)
		and checkIndexes(len modelVariables, modelStructure.initialUnknowns)

		-- All modelVariable declaredTypes must match the typeDefinitions
		and typeCheck(modelVariables, typeDefinitions)

		-- At most one variable can be <independent>
		and card { i | i in seq modelVariables & i.causality = <independent> } <= 1

		-- Model structure outputs contain every model variable of "output" causality
		and (let outputIndexes = { v | v in set inds modelVariables & modelVariables(v).causality = <output> } in
			 	if outputIndexes <> {}
			 	then
			 		modelStructure.outputs <> nil
			 		and { u.index | u in seq modelStructure.outputs } = outputIndexes
			 	else
			 		modelStructure.outputs = nil)

		-- Derivatives must refer to all variables that are Real which define the "derivative" variable
		and (let rdis = { v | v in set inds modelVariables &
				modelVariables(v).variable.derivative <> nil
				and is_Real(modelVariables(v).variable) }
			in
			 	if rdis <> {}
			 	then
			 		modelStructure.derivatives <> nil
			 		and let dis = { u.index | u in seq modelStructure.derivatives } in
			 			dis = rdis
			 			and forall i in set dis & i <= len modelVariables
			 	else
			 		modelStructure.derivatives = nil)

		-- InitalUnknowns must be all output (approx/calculated), calculatedParameters and 
		-- all continuous-time states and derivatives that are approx/calculated
		-- And the list must be in ascending index order
		and (let svs = { svi | svi in set inds modelVariables &
				let sv = modelVariables(svi),
					eInitial = effectiveInitial(sv.initial, sv.causality, sv.variability)
				in
					(sv.causality = <output> and eInitial in set { <approx>, <calculated> })
					or sv.causality = <calculatedParameter>
					or (sv in set continuousTimeStates(modelVariables) and eInitial in set { <approx>, <calculated> })
					or svi in set { u.index | u in seq modelStructure.derivatives &
						let dv = modelVariables(u.index),
							ei = effectiveInitial(dv.initial, dv.causality, dv.variability)
						in
							ei in set { <approx>, <calculated> } } }
			in
			 	if svs <> {}
			 	then
			 		let iu = modelStructure.initialUnknowns in
			 			iu <> nil
			 			and { u.index | u in seq iu } = svs
			 			and forall i in set inds iu &
			 				i = len iu or iu(i).index < iu(i+1).index
			 	else
			 		modelStructure.initialUnknowns = nil);

	/**
	 * Check that a variable index is within range
	 */
	checkIndexes: nat1 * [seq1 of Unknown] +> bool
	checkIndexes(vars, unknowns) ==
		unknowns <> nil =>
			forall u in seq unknowns & u.index <= vars;

	/**
	 * Check that all variables' declaredTypes are defined, that the variables' type match
	 * the declared type and the min/max of numeric types are compatible with the start value.
	 */
	typeCheck: seq of ScalarVariable * set of SimpleType +> bool
	typeCheck(variables, typedefs) ==
		forall v in seq variables &
			let dname = v.variable.declaredType in
				dname <> nil =>
					let simpleTypes = { td | td in set typedefs & td.name = dname } in
						-- Only one type name should match
						card simpleTypes = 1

						-- The match is the same type as the ScalarVariable type and for numerics,
						-- any start value is within the (perhaps overridden) min/max. 
						and let {simpleType} = simpleTypes in
							cases simpleType.type:
								mk_RealType(dmin, dmax, -, -) ->
									-- The named definition is the right type
									is_Real(v.variable)

									-- And any start value matches the calculated min/max
									and v.variable.start <> nil =>
										let min = if v.variable.min <> nil then v.variable.min
												  else if dmin <> nil then dmin
												  else nil,
											max = if v.variable.max <> nil then v.variable.max
												  else if dmax <> nil then dmax
												  else nil
										in
											(max <> nil and min <> nil => max >= min)
											and (min <> nil => min <= v.variable.start)
											and	(max <> nil => max >= v.variable.start),

								mk_IntegerType(dmin, dmax) ->
									-- The named definition is the right type
									is_Integer(v.variable)

									-- And any start value matches the calculated min/max
									and v.variable.start <> nil =>
										let min = if v.variable.min <> nil then v.variable.min
												  else if dmin <> nil then dmin
												  else nil,
											max = if v.variable.max <> nil then v.variable.max
												  else if dmax <> nil then dmax
												  else nil
										in
											(max <> nil and min <> nil => max >= min)
											and (min <> nil => min <= v.variable.start)
											and	(max <> nil => max >= v.variable.start),

								mk_BooleanType() ->
									is_Boolean(v.variable),

								mk_StringType() ->
									is_String(v.variable),

								mk_EnumerationType(-) ->
									is_Enumeration(v.variable)
							end;
