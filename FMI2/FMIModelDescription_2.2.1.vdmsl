/**
 * 2.2.1 Definition of an FMU (fmiModelDescription)
 */
types
	ModelAttributes ::
		fmiVersion					: seq1 of char
		modelName					: seq1 of char
		guid						: seq1 of char
		description					: [seq1 of char]
		author						: [seq1 of char]
		version						: [seq1 of char]
		copyright					: [seq1 of char]
		license						: [seq1 of char]
		generationTool				: [seq1 of char]
		generationDateAndTime		: [seq1 of char]
		variableNamingConvention	: [<flat> | <structured>]
		numberOfEventIndicators		: [nat];


	-- XSD definition on p25
	FMIModelDescription ::
		-- Just name for now, tbs ModelAttributes
		attributes			: ModelAttributes

		-- A global list of type definitions that are utilized in "ModelVariables"
		typeDefinitions		: set of SimpleType			-- XSD p38

		-- The central FMU data structure defining all variables of the FMU that
		-- Are visible/accessible via the FMU functions.
		modelVariables		: seq of ScalarVariable		-- XSD p44

		-- Defines the structure of the model. Especially, the ordered lists of
		-- outputs, continuous-time states and initial unknowns (the unknowns
		-- during Initialization Mode) are defined here. Furthermore, the
		-- dependency of the unkowns from the knowns can be optionally
		-- defined.
		modelStructure		: ModelStructure;			-- XSD p56

functions
	/**
	 * Valid description attributes.
	 */
	isValidModelAttributes: ModelAttributes +> bool
	isValidModelAttributes(attrs) ==
		-- @OnFail("%s model version should be 2.0", attrs.modelName)
		(attrs.fmiVersion in set { "2", "2.0" });

	/**
	 * Invariant definition for FMIModelDescription
	 */
	isValidModelDescription: FMIModelDescription +> bool
	isValidModelDescription(md) ==
		-- First fill in effective values for model variables' missing attributes
		let eModelVariables =
			[
				let ec = effectiveCausality(sv.causality),
					ev = effectiveVariability(sv.variability),
					ei = effectiveInitial(sv.initial, ec, ev)
				in
					mu(sv, causality |-> ec, variability |-> ev, initial |-> ei)

				| sv in seq md.modelVariables
			]
		in
		{
			-- Attributes are valid
			(
				isValidModelAttributes(md.attributes)
			),

			-- Type definitions are vaid
			(
				forall stype in set md.typeDefinitions &
					-- @OnFail("%s.TypeDefinition[%s] invalid", md.attributes.modelName, stype.name)
					(isValidType(stype))
			),

			-- Type definitions are unique by name
			-- @OnFail("%s.TypeDefinitions are not unique", md.attributes.modelName)
			(
				card { t.name | t in set md.typeDefinitions } = card md.typeDefinitions
			),

			-- All scalar variables are valid
			(
				forall sv in seq md.modelVariables &
					-- @OnFail("%s.ScalarVariables[%s] invalid", md.attributes.modelName, sv.name)
					(isValidScalarVariable(sv.causality, sv.variability, sv.initial, sv.variable))
			),

			-- All modelVariable declaredTypes must match the typeDefinitions
			-- @OnFail("%s.ScalarVariables, typecheck against type definitions failed", md.attributes.modelName)
			(
				typeCheck(eModelVariables, md.typeDefinitions)
			),

			-- At most one variable can be <independent>
			-- @OnFail("%s.ScalarVariables, more than one independent variable", md.attributes.modelName)
			(
				card { sv | sv in seq eModelVariables & sv.causality = <independent> } <= 1
			),

			-- The modelStructure is valid
			-- @OnFail("%s.ModelStructure invalid", md.attributes.modelName)
			(
				isValidModelStructure(md.modelStructure)
			),

			-- Model structure outputs contain every model variable of "output" causality
			-- @OnFail("%s.ModelStructure does not contain every <output> variable")
			(
				let outputIndexes = { svi | svi in set inds eModelVariables &
					eModelVariables(svi).causality = <output> }
				in
				 	if outputIndexes <> {}
				 	then
				 		md.modelStructure.outputs <> nil
				 		and { u.index | u in seq md.modelStructure.outputs } = outputIndexes
				 	else
				 		md.modelStructure.outputs = nil
			),

			-- Derivatives must refer to all variables that are Real which define the "derivative" variable
			-- @OnFail("%s.ModelStructure.Derivatives section does not refer to Real/derivative variable")
			(
				let derivativeIndexes = { svi | svi in set inds eModelVariables &
					is_Real(eModelVariables(svi).variable)
					and eModelVariables(svi).variable.derivative <> nil }
				in
				 	if derivativeIndexes <> {}
				 	then
				 		md.modelStructure.derivatives <> nil
				 		and let structIndexes = { u.index | u in seq md.modelStructure.derivatives } in
				 			structIndexes = derivativeIndexes
				 			and forall i in set structIndexes & i <= len eModelVariables
				 	else
				 		md.modelStructure.derivatives = nil
			),

			-- InitalUnknowns must be all output (approx/calculated), calculatedParameters and 
			-- all continuous-time states and derivatives that are approx/calculated
			-- And the list must be in ascending index order
			-- @OnFail("%s.ModelStructure.InitialUnknowns are invalid")
			(
				let initIndexes = { svi | svi in set inds eModelVariables &
					let sv = eModelVariables(svi) in
						(sv.causality = <output>
							and sv.initial in set { <approx>, <calculated> })

						or (sv.causality = <calculatedParameter>)

						or (sv in set continuousTimeStates(eModelVariables)
							and sv.initial in set { <approx>, <calculated> })

						or (md.modelStructure.derivatives <> nil
							and svi in set { u.index | u in seq md.modelStructure.derivatives &
								let dv = eModelVariables(u.index) in 
									dv.initial in set { <approx>, <calculated> } } ) }
				in
				 	if initIndexes <> {}
				 	then
				 		let ius = md.modelStructure.initialUnknowns in
				 		{
			 				-- @OnFail("InitialUnknowns should be defined: %s", initIndexes)
			 				(
				 				ius <> nil
				 			),

			 				-- @OnFail("InitialUnknowns not as expected: %s", initIndexes)
			 				(
			 					ius <> nil => { u.index | u in seq ius } = initIndexes
			 				),

			 				--@OnFail("InitialUnknowns are not sorted: %s", ius)
			 				(
			 					ius <> nil => 
					 				 forall i in set inds ius &
					 					i = len ius or ius(i).index < ius(i+1).index
				 			)
				 		} = {true}
				 	else
				 		--@OnFail("InitialUnknowns should be empty")
			 			(
				 			md.modelStructure.initialUnknowns = nil
				 		)
			)
		} = {true};

	/**
	 * Check that all variables' declaredTypes are defined, that the variables' type match
	 * the declared type and the min/max of numeric types are compatible with the start value.
	 */
	typeCheck: seq of ScalarVariable * set of SimpleType +> bool
	typeCheck(variables, typedefs) ==
		forall sv in seq variables &
			let dname = sv.variable.declaredType in
				dname <> nil =>
					let matchingTypes = { td | td in set typedefs & td.name = dname } in
					{
						-- Only one type name should match
						-- @OnFail("Typedefs have multiple matching names")
						(
							card matchingTypes = 1
						),

						-- The match is the same type as the ScalarVariable type and for numerics,
						-- any start value is within the (perhaps overridden) min/max. 
						let { simpleType } = matchingTypes in
							cases simpleType.type:
								mk_RealType(dmin, dmax, -, -) ->
								{
									-- The named definition is the right type
									-- @OnFail("ScalarVariable %s, RealType not referenced by Real variable %s", sv.name, sv.variable)
									(
										is_Real(sv.variable)
									),

									-- And any start value matches the calculated min/max
									(
										sv.variable.start <> nil =>
											let min = if sv.variable.min <> nil then sv.variable.min
													  else if dmin <> nil then dmin
													  else nil,
												max = if sv.variable.max <> nil then sv.variable.max
													  else if dmax <> nil then dmax
													  else nil
											in
												-- @OnFail("ScalarVariable %s, calculated min/max does not match start %s", sv.name, sv.variable.start)
												(max <> nil and min <> nil => max >= min)
												and (min <> nil => min <= sv.variable.start)
												and	(max <> nil => max >= sv.variable.start)
									)
								} = {true},

								mk_IntegerType(dmin, dmax) ->
								{
									-- The named definition is the right type
									-- @OnFail("ScalarVariable %s, IntegerType not referenced by Integer variable %s", sv.name, sv.variable)
									(
										is_Integer(sv.variable)
									),

									-- And any start value matches the calculated min/max
									(
										sv.variable.start <> nil =>
											let min = if sv.variable.min <> nil then sv.variable.min
													  else if dmin <> nil then dmin
													  else nil,
												max = if sv.variable.max <> nil then sv.variable.max
													  else if dmax <> nil then dmax
													  else nil
											in
												-- @OnFail("ScalarVariable %s, calculated min/max does not match start %s", sv.name, sv.variable.start)
												(max <> nil and min <> nil => max >= min)
												and (min <> nil => min <= sv.variable.start)
												and	(max <> nil => max >= sv.variable.start)
									)
								} = {true},

								mk_BooleanType() ->
									-- @OnFail("ScalarVariable %s, BooleanType not referenced by Boolean variable %s", sv.name, sv.variable)
									(is_Boolean(sv.variable)),

								mk_StringType() ->
									-- @OnFail("ScalarVariable %s, StringType not referenced by String variable %s", sv.name, sv.variable)
									(is_String(sv.variable)),

								mk_EnumerationType(-) ->
									-- @OnFail("ScalarVariable %s, EnumerationType not referenced by Enumeration variable %s", sv.name, sv.variable)
									(is_Enumeration(sv.variable))
							end
					} = {true};
