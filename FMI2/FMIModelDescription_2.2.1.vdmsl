/**
 * 2.2.1 Definition of an FMU (fmiModelDescription)
 */
types
	ModelAttributes ::
		fmiVersion					: NormalizedString1
		modelName					: AnyString
		guid						: NormalizedString1
		description					: [AnyString]
		author						: [AnyString]
		version						: [NormalizedString1]
		copyright					: [AnyString]
		license						: [AnyString]
		generationTool				: [NormalizedString1]
		generationDateAndTime		: [AnyString]
		variableNamingConvention	: [<flat> | <structured>]
		numberOfEventIndicators		: [nat];


	-- XSD definition in section 2.2.1, p25
	FMIModelDescription ::
		-- The common model attributes
		attributes			: ModelAttributes			-- XSD 2.2.1, p31

		-- ModelExchange
		modelExchange		: [ModelExchange]			-- XSD 3.3.1, p89

		-- CoSimulation
		coSimulation		: [CoSimulation ]			-- XSD 4.3.1, p109

		-- Unit Definitions that are utilized in "ModelVariables"
		unitDefinitions		: [seq1 of Unit]			-- XSD 2.2.2, p33

		-- A global list of type definitions that are utilized in "ModelVariables"
		typeDefinitions		: [set1 of SimpleType]		-- XSD 2.2.3, p38

		-- Log categories
		logCategories		: [seq1 of Category]		-- XSD 2.2.4, p42

		-- Default experiment
		defaultExperiment	: [DefaultExperiment]		-- XSD 2.2.5, p43

		-- Vendor annotations
		vendorAnnotations	: [seq1 of Tool]			-- XSD 2.2.6, p43

		-- The central FMU data structure defining all variables of the FMU that
		-- Are visible/accessible via the FMU functions.
		modelVariables		: seq1 of ScalarVariable	-- XSD 2.2.7, p44

		-- Defines the structure of the model. Especially, the ordered lists of
		-- outputs, continuous-time states and initial unknowns (the unknowns
		-- during Initialization Mode) are defined here. Furthermore, the
		-- dependency of the unknowns from the knowns can be optionally
		-- defined.
		modelStructure		: ModelStructure;			-- XSD 2.2.8, p56

functions
	/**
	 * Valid description attributes.
	 */
	isValidModelAttributes: ModelAttributes +> bool
	isValidModelAttributes(attrs) ==
		-- @OnFail("ModelAttribute fmiVersion should be 2.0")
		( attrs.fmiVersion in set { "2.0" } );

	/**
	 * Invariant definition for FMIModelDescription
	 */
	isValidFMIModelDescription: FMIModelDescription +> bool
	isValidFMIModelDescription(md) ==
		-- First fill in effective values for model variables' missing attributes
		let eModelVariables =
			[
				let ec = effectiveCausality(sv.causality),
					ev = effectiveVariability(sv.variability),
					ei = effectiveInitial(sv.initial, ec, ev)
				in
					mu(sv, causality |-> ec, variability |-> ev, initial |-> ei)

				| sv in seq md.modelVariables
			]
		in
		{
			-- @OnFail("ModelAttributes invalid")
			( isValidModelAttributes(md.attributes) ),

			-- @OnFail("ModelExchange invalid")
			( isValidModelExchange(md.modelExchange) ),

			-- @OnFail("CoSimulation invalid")
			( isValidCoSimulation(md.coSimulation) ),

			-- @OnFail("UnitDefinitions invalid")
			( isValidUnitDefinitions(md.unitDefinitions) ),

			-- @OnFail("TypeDefinitions invalid")
			( isValidTypeDefinitions(md.typeDefinitions) ),

			-- @OnFail("LogCategories invalid")
			( isValidLogCategories(md.logCategories) ),

			-- @OnFail("DefaultExperiment invalid")
			( isValidDefaultExperiment(md.defaultExperiment) ),

			-- @OnFail("VendorAnnotations invalid")
			( isValidVendorAnnotations(md.vendorAnnotations) ),

			-- @OnFail("ScalarVariables invalid")
			( isValidScalarVariables(eModelVariables) ),

			-- @OnFail("ScalarVariables typecheck against TypeDefinitions failed")
			( typeCheck(eModelVariables, md.typeDefinitions) ),

			-- @OnFail("ModelStructure invalid")
			( isValidModelStructure(md.modelStructure) ),

			-- @OnFail("No model type specified")
			( md.modelExchange <> nil or md.coSimulation <> nil ),

			(
				let outputIndexes = { svi | svi in set inds eModelVariables &
					eModelVariables(svi).causality = <output> }
				in
				 	if outputIndexes <> {}
				 	then
						-- @OnFail("ModelStructure.Outputs should be %s", outputIndexes)
				 		( md.modelStructure.outputs <> nil
				 		  and { u.index | u in seq md.modelStructure.outputs } = outputIndexes )
				 	else
				 		-- @OnFail("ModelStructure.Outputs should be omitted")
				 		( md.modelStructure.outputs = nil )
			),

			(
				let derivativeIndexes = { svi | svi in set inds eModelVariables &
					is_Real(eModelVariables(svi).variable)
					and eModelVariables(svi).variable.derivative <> nil }
				in
				 	if derivativeIndexes <> {}
				 	then
						-- @OnFail("ModelStructure.Derivatives section does not match Real/derivative variables")
				 		( md.modelStructure.derivatives <> nil
				 		  and let structIndexes = { u.index | u in seq md.modelStructure.derivatives } in
				 			structIndexes = derivativeIndexes
				 			and forall i in set structIndexes & i <= len eModelVariables )
				 	else
				 		-- @OnFail("ModelStructure.Derivatives declared, but no Real/derivative variables")
				 		( md.modelStructure.derivatives = nil )
			),

			-- InitalUnknowns must be all output (approx/calculated), calculatedParameters and 
			-- all continuous-time states and derivatives that are approx/calculated.
			-- And the list must be in ascending index order

			-- @OnFail("ModelStructure.InitialUnknowns invalid")
			(
				let initIndexes = { svi | svi in set inds eModelVariables &
					let sv = eModelVariables(svi) in
						(sv.causality = <output>
							and sv.initial in set { <approx>, <calculated> })

						or (sv.causality = <calculatedParameter>)

						or (sv in set continuousTimeStates(eModelVariables)
							and sv.initial in set { <approx>, <calculated> })

						or (md.modelStructure.derivatives <> nil
							and svi in set { u.index | u in seq md.modelStructure.derivatives &
								let dv = eModelVariables(u.index) in 
									dv.initial in set { <approx>, <calculated> } } ) }
				in
				 	if initIndexes <> {}
				 	then
				 		let ius = md.modelStructure.initialUnknowns in
				 		{
			 				-- @OnFail("InitialUnknowns should be: %s", initIndexes)
			 				( ius <> nil ),

			 				-- @OnFail("InitialUnknowns should be: %s", initIndexes)
			 				( ius <> nil => { u.index | u in seq ius } = initIndexes ),

			 				-- @OnFail("InitialUnknowns are not sorted: %s", [ u.index | u in seq ius ])
			 				( ius <> nil => 
					 				forall i in set inds ius &
					 					i = len ius or ius(i).index < ius(i+1).index )
				 		} = {true}
				 	else
				 		-- @OnFail("InitialUnknowns should be empty")
			 			( md.modelStructure.initialUnknowns = nil )
			)
		} = {true};

	/**
	 * Check that all variables' declaredTypes are defined, that the variables' types match
	 * the declared types and the min/max of numeric types are compatible with the start value.
	 */
	typeCheck: seq1 of ScalarVariable * [set1 of SimpleType] +> bool
	typeCheck(variables, typedefs) ==
		{
			let dname = sv.variable.declaredType in
				dname <> nil =>
					let matchingTypes = { td | td in set nilSet[SimpleType](typedefs) & td.name = dname } in
					{
						-- @OnFail("Typedefs have multiple matching names")
						( card matchingTypes = 1 ),

						-- The match is the same type as the ScalarVariable type and for numerics,
						-- and any start value is within the (perhaps overridden) min/max. 
						let { simpleType } = matchingTypes in
							cases simpleType.type:
								mk_RealType(dmin, dmax, -, -) ->
								{
									-- @OnFail("ScalarVariable %s, RealType not referenced by Real variable %s", sv.name, sv.variable.declaredType)
									( is_Real(sv.variable) ),

									-- And any start value matches the calculated min/max
									(
										sv.variable.start <> nil =>
											let min = if sv.variable.min <> nil then sv.variable.min
													  else if dmin <> nil then dmin
													  else nil,
												max = if sv.variable.max <> nil then sv.variable.max
													  else if dmax <> nil then dmax
													  else nil
											in
												-- @OnFail("ScalarVariable %s, calculated min/max does not match start %s", sv.name, sv.variable.start)
												(
													(max <> nil and min <> nil => max >= min)
													and (min <> nil => min <= sv.variable.start)
													and	(max <> nil => max >= sv.variable.start)
												)
									)
								} = {true},

								mk_IntegerType(dmin, dmax) ->
								{
									-- @OnFail("ScalarVariable %s, IntegerType not referenced by Integer variable %s", sv.name, sv.variable.declaredType)
									( is_Integer(sv.variable) ),

									-- And any start value matches the calculated min/max
									(
										sv.variable.start <> nil =>
											let min = if sv.variable.min <> nil then sv.variable.min
													  else if dmin <> nil then dmin
													  else nil,
												max = if sv.variable.max <> nil then sv.variable.max
													  else if dmax <> nil then dmax
													  else nil
											in
												-- @OnFail("ScalarVariable %s, calculated min/max does not match start %s", sv.name, sv.variable.start)
												(
													(max <> nil and min <> nil => max >= min)
													and (min <> nil => min <= sv.variable.start)
													and	(max <> nil => max >= sv.variable.start)
												)
									)
								} = {true},

								mk_BooleanType() ->
									-- @OnFail("ScalarVariable %s, BooleanType not referenced by Boolean variable %s", sv.name, sv.variable.declaredType)
									( is_Boolean(sv.variable) ),

								mk_StringType() ->
									-- @OnFail("ScalarVariable %s, StringType not referenced by String variable %s", sv.name, sv.variable.declaredType)
									( is_String(sv.variable) ),

								mk_EnumerationType(-) ->
									-- @OnFail("ScalarVariable %s, EnumerationType not referenced by Enumeration variable %s", sv.name, sv.variable.declaredType)
									( is_Enumeration(sv.variable) )
							end
					} = {true}
			| sv in seq variables
		} = {true};
