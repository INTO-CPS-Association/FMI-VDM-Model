/**
 * 2.2.1 Definition of an FMU (fmiModelDescription)
 */
types
	-- XSD definition on p25
	FMIModelDescription ::
		-- A global list of type definitions that are utilized in "ModelVariables"
		typeDefinitions		: set of SimpleType			-- XSD p38

		-- The central FMU data structure defining all variables of the FMU that
		-- Are visible/accessible via the FMU functions.
		modelVariables		: seq of ScalarVariable		-- XSD p44

		-- Defines the structure of the model. Especially, the ordered lists of
		-- outputs, continuous-time states and initial unknowns (the unknowns
		-- during Initialization Mode) are defined here. Furthermore, the
		-- dependency of the unkowns from the knowns can be optionally
		-- defined.
		modelStructure		: ModelStructure			-- XSD p56

	inv m ==
		isValidModelDescription(m.typeDefinitions, m.modelVariables, m.modelStructure);

functions
	/**
	 * Invariant definition for FMIModelDescription
	 */
	isValidModelDescription: set of SimpleType * seq of ScalarVariable * ModelStructure +> bool
	isValidModelDescription(typeDefinitions, modelVariables, modelStructure) ==
		-- First fill in effective fields for model variables
		let eModelVariables =
			[
				let ec = effectiveCausality(sv.causality),
					ev = effectiveVariability(sv.variability),
					ei = effectiveInitial(sv.initial, ec, ev)
				in
					mu(sv, causality |-> ec, variability |-> ev, initial |-> ei)

				| sv in seq modelVariables
			]
		in
			-- Type definitions are unique by name
			-- @OnFail("Type definitions are not unique")
			(
				card { t.name | t in set typeDefinitions } = card typeDefinitions
			)
			and
			-- All modelStructure variables must be declared in modelVariables
			-- @OnFail("Model structure indexes do not match model variables")
			(
				checkIndexes(len eModelVariables, modelStructure.outputs)
				and checkIndexes(len eModelVariables, modelStructure.derivatives)
				and checkIndexes(len eModelVariables, modelStructure.initialUnknowns)
			)
			and
			-- All modelVariable declaredTypes must match the typeDefinitions
			-- @OnFail("Typecheck of model variables against type definitions failed")
			(
				typeCheck(eModelVariables, typeDefinitions)
			)
			and
			-- At most one variable can be <independent>
			-- @OnFail("Must be at most one independent variable")
			(
				card { sv | sv in seq eModelVariables & sv.causality = <independent> } <= 1
			)
			and
			-- Model structure outputs contain every model variable of "output" causality
			-- @OnFail("Model structure does not contain every <output> variable")
			(
				let outputIndexes = { svi | svi in set inds eModelVariables &
					eModelVariables(svi).causality = <output> }
				in
				 	if outputIndexes <> {}
				 	then
				 		modelStructure.outputs <> nil
				 		and { u.index | u in seq modelStructure.outputs } = outputIndexes
				 	else
				 		modelStructure.outputs = nil
			)
			and
			-- Derivatives must refer to all variables that are Real which define the "derivative" variable
			-- @OnFail("Derivative section does not refer to Real/derivative variable")
			(
				let derivativeIndexes = { svi | svi in set inds eModelVariables &
					is_Real(eModelVariables(svi).variable)
					and eModelVariables(svi).variable.derivative <> nil }
				in
				 	if derivativeIndexes <> {}
				 	then
				 		modelStructure.derivatives <> nil
				 		and let structIndexes = { u.index | u in seq modelStructure.derivatives } in
				 			structIndexes = derivativeIndexes
				 			and forall i in set structIndexes & i <= len eModelVariables
				 	else
				 		modelStructure.derivatives = nil
			)
			and
			-- InitalUnknowns must be all output (approx/calculated), calculatedParameters and 
			-- all continuous-time states and derivatives that are approx/calculated
			-- And the list must be in ascending index order
			(
				let initIndexes = { svi | svi in set inds eModelVariables &
					let sv = eModelVariables(svi) in
						(sv.causality = <output>
							and sv.initial in set { <approx>, <calculated> })

						or (sv.causality = <calculatedParameter>)

						or (sv in set continuousTimeStates(eModelVariables)
							and sv.initial in set { <approx>, <calculated> })

						or (modelStructure.derivatives <> nil
							and svi in set { u.index | u in seq modelStructure.derivatives &
								let dv = eModelVariables(u.index) in 
									dv.initial in set { <approx>, <calculated> } } ) }
				in
					-- @OnFail("InitialUnknowns are invalid")
					(
					 	if initIndexes <> {}
					 	then
					 		let ius = modelStructure.initialUnknowns in
				 				-- @OnFail("InitialUnknowns should be defined: %s", initIndexes)
				 				(
					 				ius <> nil
					 			)
					 			and
				 				-- @OnFail("InitialUnknowns not as expected: %s", initIndexes)
				 				(
				 					{ u.index | u in seq ius } = initIndexes
				 				)
					 			and
				 				--@OnFail("InitialUnknowns are not sorted: %s", ius)
				 				(
					 				 forall i in set inds ius &
					 					i = len ius or ius(i).index < ius(i+1).index
					 			)
					 	else
					 		modelStructure.initialUnknowns = nil
				 	)
			);

	/**
	 * Check that a variable index is within range
	 */
	checkIndexes: nat1 * [seq1 of Unknown] +> bool
	checkIndexes(vars, unknowns) ==
		unknowns <> nil =>
			forall u in seq unknowns & u.index <= vars;

	/**
	 * Check that all variables' declaredTypes are defined, that the variables' type match
	 * the declared type and the min/max of numeric types are compatible with the start value.
	 */
	typeCheck: seq of ScalarVariable * set of SimpleType +> bool
	typeCheck(variables, typedefs) ==
		forall sv in seq variables &
			let dname = sv.variable.declaredType in
				dname <> nil =>
					let matchingTypes = { td | td in set typedefs & td.name = dname } in
						-- Only one type name should match
						-- @OnFail("Typedefs have multiple matching names")
						(card matchingTypes = 1)

						-- The match is the same type as the ScalarVariable type and for numerics,
						-- any start value is within the (perhaps overridden) min/max. 
						and let { simpleType } = matchingTypes in
							cases simpleType.type:
								mk_RealType(dmin, dmax, -, -) ->
									-- The named definition is the right type
									-- @OnFail("RealType not referenced by Real variable %s", sv.variable)
									(is_Real(sv.variable))

									-- And any start value matches the calculated min/max
									and (sv.variable.start <> nil =>
										let min = if sv.variable.min <> nil then sv.variable.min
												  else if dmin <> nil then dmin
												  else nil,
											max = if sv.variable.max <> nil then sv.variable.max
												  else if dmax <> nil then dmax
												  else nil
										in
											-- @OnFail("Calculated min/max does not match start %s", sv.variable.start)
											(max <> nil and min <> nil => max >= min)
											and (min <> nil => min <= sv.variable.start)
											and	(max <> nil => max >= sv.variable.start)),

								mk_IntegerType(dmin, dmax) ->
									-- The named definition is the right type
									-- @OnFail("IntegerType not referenced by Integer variable %s", sv.variable)
									(is_Integer(sv.variable))

									-- And any start value matches the calculated min/max
									and (sv.variable.start <> nil =>
										let min = if sv.variable.min <> nil then sv.variable.min
												  else if dmin <> nil then dmin
												  else nil,
											max = if sv.variable.max <> nil then sv.variable.max
												  else if dmax <> nil then dmax
												  else nil
										in
											-- @OnFail("Calculated min/max does not match start %s", sv.variable.start)
											(max <> nil and min <> nil => max >= min)
											and (min <> nil => min <= sv.variable.start)
											and	(max <> nil => max >= sv.variable.start)),

								mk_BooleanType() ->
									-- @OnFail("BooleanType not referenced by Boolean variable %s", sv.variable)
									(is_Boolean(sv.variable)),

								mk_StringType() ->
									-- @OnFail("StringType not referenced by String variable %s", sv.variable)
									(is_String(sv.variable)),

								mk_EnumerationType(-) ->
									-- @OnFail("EnumerationType not referenced by Enumeration variable %s", sv.variable)
									(is_Enumeration(sv.variable))
							end;
