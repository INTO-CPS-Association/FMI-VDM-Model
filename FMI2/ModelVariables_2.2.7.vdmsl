/**
 * 2.2.7 Definition of Model Variables (ModelVariables)
 */
types
	-- XSD p45, description p46
	Causality	= <parameter> | <calculatedParameter> | <input> | <output> | <local> | <independent>;

	-- XSD p45, description p46
	Variability	= <constant> | <fixed> | <tunable> | <discrete> | <continuous>;

	-- XSD p45, description p46
	Initial		= <exact> | <approx> | <calculated>;

	Real ::		-- XSD p52
		declaredType	: [seq1 of char]
		min				: [real]
		max				: [real]
		nominal			: [real]
		unbounded		: [bool]
		start			: [real]
		derivative		: [nat1]
	inv r ==
		(r.max <> nil and r.min <> nil =>
			--@OnFail("Real min %s is not <= max %s", r.min, r.max)
			(r.max >= r.min))
		and	(r.start <> nil =>
			--@OnFail("Real start %s is not within min %s/max %s", r.start, r.min, r.max)
			((r.min <> nil => r.min <= r.start) and
			 (r.max <> nil => r.max >= r.start)));

	Integer ::	-- XSD p52
		declaredType	: [seq1 of char]
		min				: [int]
		max				: [int]
		start			: [int]
	inv i ==
		(i.max <> nil and i.min <> nil =>
			--@OnFail("Integer min %s is not <= max %s", i.min, i.max)
			(i.max >= i.min))
		and	(i.start <> nil =>
			--@OnFail("Integer start %s is not within min %s/max %s", i.start, i.min, i.max)
			((i.min <> nil => i.min <= i.start) and
			 (i.max <> nil => i.max >= i.start)));

	Boolean ::		-- XSD p53
		declaredType	: [seq1 of char]
		start			: [bool];

	String ::		-- XSD p53
		declaredType	: [seq1 of char]
		start			: [seq1 of char];

	Enumeration ::	-- XSD p53
		declaredType	: seq1 of char	-- Note, not optional
		min				: [int]
		max				: [int]
		start			: [int]
	inv e ==
		(e.max <> nil and e.min <> nil =>
			--@OnFail("Enum min %s is not <= max %s", e.min, e.max)
			(e.max >= e.min))
		and	(e.start <> nil =>
			--@OnFail("Enum start %s is not within min %s/max %s", e.start, e.min, e.max)
			((e.min <> nil => e.min <= e.start) and
			 (e.max <> nil => e.max >= e.start)));

	Variable = Real | Integer | Boolean | String | Enumeration;

	VarName = seq1 of char;		-- Has a syntax defined in section 2.2.9, p64

	ScalarVariable ::			-- XSD p44
		-- attributes
		name		: VarName
		causality	: [Causality]
		variability	: [Variability]
		initial		: [Initial]

		-- elements
		variable	: Variable

	inv sv ==
		isValidSV(sv.causality, sv.variability, sv.initial, sv.variable);

functions
	/**
	 * Rules defined in the table on p49.
	 */
	isValidSV: [Causality] * [Variability] * [Initial] * Variable +> bool
	isValidSV(causality, variability, initial, variable) ==
		let eCausality = effectiveCausality(causality),
			eVariability = effectiveVariability(variability),
			eInitial = effectiveInitial(initial, eCausality, eVariability)
		in
			-- Table on p46 defining causality, and p49 defining combinations
			-- @OnFail("Causality %s fails", eCausality)
			(
				cases eCausality:
					<parameter> ->
						eVariability in set {<fixed>, <tunable>}
						and eInitial = <exact>,

					<calculatedParameter> ->
						eVariability in set {<fixed>, <tunable>}
						and eInitial in set {<approx>, <calculated>},

					<input> ->
						eVariability in set {<discrete>, <continuous>}
						and eInitial = nil,

					<independent> ->
						eVariability = <continuous>
						and eInitial = nil
						and is_Real(variable)
						and variable.start = nil,

					<output> ->
						eVariability in set {<constant>, <discrete>, <continuous>}
						and eInitial in set {<exact>, <approx>, <calculated>},

					<local> ->
						true
				end
			)
			and
			-- Table on p46 defining variability, and p49 defining combinations
			-- @OnFail("Variability %s fails", eVariability)
			(
				cases eVariability:
					<constant> ->
						eCausality in set {<output>, <local>},

					<fixed>, <tunable> ->
						eCausality in set {<parameter>, <calculatedParameter>, <local>},

					<discrete> ->
						eCausality in set {<input>, <output>, <local>},

					<continuous> ->
						eCausality in set {<input>, <output>, <local>, <independent>}
						and is_Real(variable)
				end
			)
			and
			-- Table on p47 defining initial
			-- @OnFail("Initial %s fails", initial)
			(
				initial <> nil =>
					(eCausality not in set {<input>, <independent>})
			)
			and
			-- Table on p47 defining initial
			-- @OnFail("Initial %s fails", eInitial)
			(
				cases eInitial:
					<exact> ->
						variable.start <> nil,

					<approx> ->
						variable.start <> nil
						and variability <> <constant>,

					<calculated> ->
						variable.start = nil
						and variability <> <constant>,

					nil ->		-- Note that eInitial can be nil (undefined in table on p48)
						true	-- Tests on eInitial above are sufficient
				end
			);

	/**
	 * The default value for initial, defined by the (effective) values of causality and
	 * variability, via the table on p48/49.
	 */ 
	effectiveInitial: [Initial] * Causality * Variability -> [Initial]
	effectiveInitial(i, eCausality, eVariability) ==
		if i <> nil
		then i
		else cases eCausality:
			<parameter> ->
				cases eVariability:
					<fixed>, <tunable> -> <exact>,
					others -> nil
				end,

			<calculatedParameter> ->
				cases eVariability:
					<fixed>, <tunable> -> <calculated>,
					others -> nil
				end,

			<input> ->
				cases eVariability:
					<discrete>, <continuous> -> nil,
					others -> nil
				end,

			<output> ->
				cases eVariability:
					<constant> -> <exact>,
					<discrete>, <continuous> -> <calculated>,
					others -> nil
				end,

			<local> ->
				cases eVariability:
					<constant> -> <exact>,
					<fixed>, <tunable> -> <calculated>,
					<discrete>, <continuous> -> <calculated>
				end,

			<independent> ->
				cases eVariability:
					<continuous> -> nil,
					others -> nil
				end
		end;

	effectiveCausality: [Causality] -> Causality
	effectiveCausality(c) ==
		if c = nil
		then <local>
		else c;

	effectiveVariability: [Variability] -> Variability
	effectiveVariability(v) ==
		if v = nil
		then <continuous>
		else v;

	/**
	 * Return the ScalarVariables from a list which are continuous-time states, defined to be
	 * variables which are the derivative of some other variable.
	 */
	continuousTimeStates: seq of ScalarVariable -> set of ScalarVariable
	continuousTimeStates(svs) ==
		{ sv | sv in seq svs &
			is_Real(sv.variable)
			and sv.variability = <continuous> 
			and sv.variable.derivative <> nil };
