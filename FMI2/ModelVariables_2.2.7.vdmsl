/**
 * 2.2.7 Definition of Model Variables (ModelVariables)
 */
types
	-- XSD p45, description p46
	Causality	= <parameter> | <calculatedParameter> | <input> | <output> | <local> | <independent>;

	-- XSD p45, description p46
	Variability	= <constant> | <fixed> | <tunable> | <discrete> | <continuous>;

	-- XSD p45, description p46
	Initial		= <exact> | <approx> | <calculated>;

	Real ::		-- XSD p52
		declaredType	: [RealType]
		min				: [real]
		max				: [real]
		nominal			: [real]
		unbounded		: [bool]
		start			: [real]
		derivative		: [nat1]
	inv r ==
		let min = if r.min <> nil then r.min
				  else if r.declaredType <> nil then r.declaredType.min
				  else nil,
			max = if r.max <> nil then r.max
				  else if r.declaredType <> nil then r.declaredType.max
				  else nil
		in
			(max <> nil and min <> nil => max >= min)
			and r.start <> nil =>
				(min <> nil => min <= r.start) and
				(max <> nil => max >= r.start);

	Integer ::	-- XSD p52
		declaredType	: [IntegerType]
		min				: [int]
		max				: [int]
		start			: [int]
	inv i ==
		let min = if i.min <> nil then i.min
				  else if i.declaredType <> nil then i.declaredType.min
				  else nil,
			max = if i.max <> nil then i.max
				  else if i.declaredType <> nil then i.declaredType.max
				  else nil
		in
			(max <> nil and min <> nil => max >= min)
			and i.start <> nil =>
				(min <> nil => min <= i.start) and
				(max <> nil => max >= i.start);

	Boolean ::		-- XSD p53
		declaredType	: [BooleanType]
		start			: [bool];

	String ::		-- XSD p53
		declaredType	: [StringType]
		start			: [seq1 of char];

	Enumeration ::	-- XSD p53
		declaredType	: EnumerationType	-- Note, not optional
		min				: [int]
		max				: [int]
		start			: [int]
	inv e ==
		-- No overrides of the EnumerationType here, unlike Real/Integer
		(e.max <> nil and e.min <> nil => e.max >= e.min)
		and e.start <> nil =>
			(e.min <> nil => e.min <= e.start) and
			(e.max <> nil => e.max >= e.start);

	Variable = Real | Integer | Boolean | String | Enumeration;

	VarName = seq1 of char;		-- Has a syntax defined in section 2.2.9, p64

	ScalarVariable ::			-- XSD p44
		-- attributes
		name		: VarName
		causality	: [Causality]
		variability	: [Variability]
		initial		: [Initial]

		-- elements
		variable	: Variable

	inv sv ==
		isValidSV(sv.causality, sv.variability, sv.initial, sv.variable);

functions
	/**
	 * Rules defined in the table on p49.
	 */
	isValidSV: [Causality] * [Variability] * [Initial] * Variable +> bool
	isValidSV(causality, variability, initial, variable) ==
		let eCausality = effectiveCausality(causality),
			eVariability = effectiveVariability(variability),
			eInitial = effectiveInitial(initial, eCausality, eVariability)
		in
			-- Table on p46 defining causality, and p49 defining combinations
			cases eCausality:
				<parameter> ->
					eVariability in set {<fixed>, <tunable>}
					and eInitial = <exact>,

				<calculatedParameter> ->
					eVariability in set {<fixed>, <tunable>}
					and eInitial in set {<approx>, <calculated>},

				<input> ->
					eVariability in set {<discrete>, <continuous>}
					and eInitial = nil,

				<independent> ->
					eVariability = <continuous>
					and eInitial = nil
					and is_Real(variable)
					and variable.start = nil,

				<output> ->
					eVariability in set {<constant>, <discrete>, <continuous>}
					and eInitial in set {<exact>, <calculated>},

				<local> ->
					true
			end

			-- Table on p46 defining variability, and p49 defining combinations
			and	cases eVariability:
				<constant> ->
					eCausality in set {<output>, <local>},

				<fixed>, <tunable> ->
					eCausality in set {<parameter>, <calculatedParameter>, <local>},

				<discrete> ->
					eCausality in set {<input>, <output>, <local>},

				<continuous> ->
					eCausality in set {<input>, <output>, <local>, <independent>}
					and is_Real(variable)
			end

			-- Table on p47 defining initial
			and (initial <> nil =>
				eCausality not in set {<input>, <independent>})

			-- Table on p47 defining initial
			and cases eInitial:
				<exact> ->
					variable.start <> nil,

				<approx> ->
					variable.start <> nil
					and variability <> <constant>,

				<calculated> ->
					variable.start = nil
					and variability <> <constant>,

				nil ->		-- Note that eInitial can be nil (undefined in table on p48)
					true	-- Tests on eInitial above are sufficient
			end;

	/**
	 * The default value for initial, defined by the (effective) values of causality and
	 * variability, via the table on p48/49.
	 */ 
	effectiveInitial: [Initial] * Causality * Variability -> [Initial]
	effectiveInitial(i, eCausality, eVariability) ==
		if i <> nil
		then i
		else cases eCausality:
			<parameter> ->
				cases eVariability:
					<fixed>, <tunable> -> <exact>,
					others -> nil
				end,

			<calculatedParameter> ->
				cases eVariability:
					<fixed>, <tunable> -> <calculated>,
					others -> nil
				end,

			<input> ->
				cases eVariability:
					<discrete>, <continuous> -> nil,
					others -> nil
				end,

			<output> ->
				cases eVariability:
					<constant> -> <exact>,
					<discrete>, <continuous> -> <calculated>,
					others -> nil
				end,

			<local> ->
				cases eVariability:
					<constant> -> <exact>,
					<fixed>, <tunable> -> <calculated>,
					<discrete>, <continuous> -> <calculated>
				end,

			<independent> ->
				cases eVariability:
					<continuous> -> nil,
					others -> nil
				end
		end;

	effectiveCausality: [Causality] -> Causality
	effectiveCausality(c) ==
		if c = nil
		then <local>
		else c;

	effectiveVariability: [Variability] -> Variability
	effectiveVariability(v) ==
		if v = nil
		then <continuous>
		else v;
