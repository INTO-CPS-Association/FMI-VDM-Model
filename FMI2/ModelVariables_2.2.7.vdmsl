/**
 * This file is part of the INTO-CPS toolchain.
 *
 * Copyright (c) 2017-2019, INTO-CPS Association,
 * c/o Professor Peter Gorm Larsen, Department of Engineering
 * Finlandsgade 22, 8200 Aarhus N.
 *
 * All rights reserved.
 *
 * THIS PROGRAM IS PROVIDED UNDER THE TERMS OF GPL VERSION 3 LICENSE OR
 * THIS INTO-CPS ASSOCIATION PUBLIC LICENSE VERSION 1.0.
 * ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS PROGRAM CONSTITUTES
 * RECIPIENT'S ACCEPTANCE OF THE OSMC PUBLIC LICENSE OR THE GPL 
 * VERSION 3, ACCORDING TO RECIPIENTS CHOICE.
 *
 * The INTO-CPS toolchain  and the INTO-CPS Association Public License are
 * obtained from the INTO-CPS Association, either from the above address, from
 * the URLs: http://www.into-cps.org, and in the INTO-CPS toolchain distribution.
 * GNU version 3 is obtained from: http://www.gnu.org/copyleft/gpl.html.
 *
 * This program is distributed WITHOUT ANY WARRANTY; without
 * even the implied warranty of  MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE, EXCEPT AS EXPRESSLY SET FORTH IN THE
 * BY RECIPIENT SELECTED SUBSIDIARY LICENSE CONDITIONS OF
 * THE INTO-CPS ASSOCIATION.
 *
 * See the full INTO-CPS Association Public License conditions for more details.
 */

/**
 * 2.2.7 Definition of Model Variables (ModelVariables)
 */
types
	-- XSD p45, description p46
	Causality	= <parameter> | <calculatedParameter> | <input> | <output> | <local> | <independent>;

	-- XSD p45, description p46
	Variability	= <constant> | <fixed> | <tunable> | <discrete> | <continuous>;

	-- XSD p45, description p46
	Initial		= <exact> | <approx> | <calculated>;

	Real ::		-- XSD p52
		declaredType	: [NormalizedString1]
		min				: [real]
		max				: [real]
		nominal			: [real]
		unbounded		: [bool]
		start			: [real]
		derivative		: [nat1];

	Integer ::	-- XSD p52
		declaredType	: [NormalizedString1]
		min				: [int]
		max				: [int]
		start			: [int];

	Boolean ::		-- XSD p53
		declaredType	: [NormalizedString1]
		start			: [bool];

	String ::		-- XSD p53
		declaredType	: [NormalizedString1]
		start			: [AnyString];

	Enumeration ::	-- XSD p53
		declaredType	: NormalizedString1	-- Note, not optional
		min				: [int]
		max				: [int]
		start			: [int];

	Variable = Real | Integer | Boolean | String | Enumeration;

	VarName = NormalizedString1;		-- Has a syntax defined in section 2.2.9, p64

	ScalarVariable ::	-- XSD 2.2.7, p44, p54
		location							: Location
		-- attributes
		name								: VarName
		causality							: [Causality]
		variability							: [Variability]
		initial								: [Initial]
		canHandleMultipleSetPerTimeInstant	: [bool]

		-- elements
		variable		: Variable
		annotations		: [seq1 of Tool];

functions
	/**
	 * Invariant helper for min/max/start checks on Real, Integer and Enumeration.
	 */
	isInRange[@T]: [@T] * [@T] * [@T] +> bool
	isInRange(min, max, start) ==
	{
		max <> nil and min <> nil =>
			--@OnFail("2.2.7 min %s is not <= max %s", min, max)
			( max >= min ),

		start <> nil =>
			--@OnFail("2.2.7 start %s is not within min %s/max %s", start, min, max)
			( (min <> nil => min <= start) and
			  (max <> nil => max >= start) )
	} = {true}
	pre is_(min, [real]) and is_(max, [real]) and is_(start, [real]);	-- ie. numerics

	/**
	 * Verify a sequence of ScalarVariables.
	 */
	isValidScalarVariables: seq1 of ScalarVariable +> bool
    isValidScalarVariables(svs) ==
        {
            /* @OnFail("2.2.7 ScalarVariables define more than one independent variable: %s",
            	{ sv.name | sv in seq svs & sv.causality = <independent> }) */
            ( card { sv | sv in seq svs & sv.causality = <independent> } <= 1 ),

            /* @OnFail("2.2.7 ScalarVariable names are not unique: %s",
            	{ svs(a).name | a, b in set inds svs &
            		a <> b and svs(a).name = svs(b).name } ) */
            ( card { sv.name | sv in seq svs } = len svs )
        }
        union
        {
            -- @OnFail("2.2.7 ScalarVariables[%s] invalid at line %s", sv.name, sv.location)
            ( isValidScalarVariable(sv) )

            | sv in seq svs
        } = {true};

	/**
	 * ScalarVariable invariant. Rules defined in the table on p49.
	 */
	isValidScalarVariable: ScalarVariable +> bool
	isValidScalarVariable(sv) ==
		let eCausality = effectiveCausality(sv.causality),
			eVariability = effectiveVariability(sv.variability),
			eInitial = effectiveInitial(sv.initial, eCausality, eVariability)
		in
		{
			-- Table on p46 defining causality, and p48/49 defining combinations
			/* @OnFail("2.2.7 Causality/variability/initial/start %s/%s/%s/%s invalid at line %s",
				eCausality, eVariability, eInitial, sv.variable.start, sv.location) */
			(
				cases eCausality:
					<parameter> ->
						eVariability in set {<fixed>, <tunable>}
						and eInitial = <exact>,		-- (A)

					<calculatedParameter> ->
						eVariability in set {<fixed>, <tunable>}
						and eInitial in set {<approx>, <calculated>},	-- (B)

					<input> ->
						eVariability in set {<discrete>, <continuous>}
						and eInitial = nil
						and sv.variable.start <> nil,		-- (D)

					<independent> ->
						eVariability = <continuous>
						and eInitial = nil		-- (D)
						and is_Real(sv.variable)
						and sv.variable.start = nil,

					<output> ->
						cases eVariability:
							<constant> ->
								eInitial in set {<exact>},	-- (A)

							<discrete>,
							<continuous> ->
								eInitial in set { <exact>, <approx>, <calculated> }, -- (C)

							others -> false
						end,

					<local> ->
						cases eVariability:
							<constant> ->
								eInitial = <exact>,	-- (A)

							<fixed>,
							<tunable> ->
								eInitial in set { <calculated>, <approx> },	-- (B)

							<discrete>,
							<continuous> ->
								eInitial in set { <exact>, <approx>, <calculated> } -- (C)
						end
				end
			),

			-- Table on p46 defining variability, and p49 defining combinations
			/* @OnFail("2.2.7 Variability/causality %s/%s invalid at line %s",
				eVariability, eCausality, sv.location) */
			(
				cases eVariability:
					<constant> ->
						eCausality in set {<output>, <local>},

					<fixed>, <tunable> ->
						eCausality in set {<parameter>, <calculatedParameter>, <local>},

					<discrete> ->
						eCausality in set {<input>, <output>, <local>},

					<continuous> ->
						eCausality in set {<input>, <output>, <local>, <independent>}
						and is_Real(sv.variable)
				end
			),

			-- Table on p47 defining initial
			/* @OnFail("2.2.7 Initial/causality %s/%s invalid at %s",
				sv.initial, eCausality, sv.location) */
			(
				sv.initial <> nil =>
					(eCausality not in set {<input>, <independent>})
			),

			-- Table on p47 defining initial
			/* @OnFail("2.2.7 Initial/variability/start %s/%s/%s invalid at line %s",
				eInitial, eVariability, sv.variable.start, sv.location) */
			(
				cases eInitial:
					<exact> ->
						sv.variable.start <> nil,

					<approx> ->
						sv.variable.start <> nil
						and eVariability <> <constant>,

					<calculated> ->
						sv.variable.start = nil
						and eVariability <> <constant>,

					nil ->		-- Note that eInitial can be nil (undefined in table on p48)
						true	-- Tests on eInitial above are sufficient
				end
			),

			-- @OnFail("2.2.7 Variable min/max/start invalid at line %s", sv.location)
			(
				cases sv.variable:
					mk_Real(-, min, max, -, -, start, -) ->
						isInRange[real](min, max, start),

					mk_Integer(-, min, max, start) ->
						isInRange[real](min, max, start),

					mk_Enumeration(-, min, max, start) ->
						isInRange[real](min, max, start),

					others -> true		-- String, Boolean
				end
			),

			-- @OnFail("2.2.7 VendorAnnotations invalid")
			( isValidVendorAnnotations(sv.annotations) )
		} = {true};

	/**
	 * The default value for initial, defined by the (effective) values of causality and
	 * variability, via the table on p48/49.
	 */ 
	effectiveInitial: [Initial] * Causality * Variability -> [Initial]
	effectiveInitial(i, eCausality, eVariability) ==
		if i <> nil
		then i
		else cases eCausality:
			<parameter> ->
				cases eVariability:
					<fixed>, <tunable> -> <exact>,
					others -> nil
				end,

			<calculatedParameter> ->
				cases eVariability:
					<fixed>, <tunable> -> <calculated>,
					others -> nil
				end,

			<input> ->
				cases eVariability:
					<discrete>, <continuous> -> nil,
					others -> nil
				end,

			<output> ->
				cases eVariability:
					<constant> -> <exact>,
					<discrete>, <continuous> -> <calculated>,
					others -> nil
				end,

			<local> ->
				cases eVariability:
					<constant> -> <exact>,
					<fixed>, <tunable> -> <calculated>,
					<discrete>, <continuous> -> <calculated>
				end,

			<independent> ->
				cases eVariability:
					<continuous> -> nil,
					others -> nil
				end
		end;

	effectiveCausality: [Causality] -> Causality
	effectiveCausality(c) ==
		if c = nil
		then <local>
		else c;

	effectiveVariability: [Variability] -> Variability
	effectiveVariability(v) ==
		if v = nil
		then <continuous>
		else v;

	effectiveScalarVariable: ScalarVariable +> ScalarVariable
	effectiveScalarVariable(sv) ==
		let causality   = effectiveCausality(sv.causality),
			variability = effectiveVariability(sv.variability)
		in 
			mk_ScalarVariable
			(
				sv.location,
				sv.name,
				causality,
				variability,
				effectiveInitial(sv.initial, causality, variability),
				sv.canHandleMultipleSetPerTimeInstant,
				sv.variable,
				sv.annotations
			);

	/**
	 * Return the ScalarVariables from a list which are continuous-time states, defined to be
	 * Real variables which are continuous and have a derivative.
	 */
	continuousTimeStates: seq of ScalarVariable -> set of ScalarVariable
	continuousTimeStates(svs) ==
		{ svs(i) | i in set inds svs &
			is_Real(svs(i).variable)
			and svs(i).variability = <continuous> 
			and exists j in set inds svs &
				is_Real(svs(j).variable) and svs(j).variable.derivative = i };

	/**
	 * Return the ScalarVariables from a list which are state derivatives, defined to be
	 * variables which are the derivative of some other variable.
	 */
	stateDerivatives: seq of ScalarVariable -> set of ScalarVariable
	stateDerivatives(svs) ==
		{ sv | sv in seq svs &
			is_Real(sv.variable) and sv.variable.derivative <> nil };
