/**
 * This file is part of the INTO-CPS toolchain.
 *
 * Copyright (c) 2017-2019, INTO-CPS Association,
 * c/o Professor Peter Gorm Larsen, Department of Engineering
 * Finlandsgade 22, 8200 Aarhus N.
 *
 * All rights reserved.
 *
 * THIS PROGRAM IS PROVIDED UNDER THE TERMS OF GPL VERSION 3 LICENSE OR
 * THIS INTO-CPS ASSOCIATION PUBLIC LICENSE VERSION 1.0.
 * ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS PROGRAM CONSTITUTES
 * RECIPIENT'S ACCEPTANCE OF THE OSMC PUBLIC LICENSE OR THE GPL 
 * VERSION 3, ACCORDING TO RECIPIENTS CHOICE.
 *
 * The INTO-CPS toolchain  and the INTO-CPS Association Public License are
 * obtained from the INTO-CPS Association, either from the above address, from
 * the URLs: http://www.into-cps.org, and in the INTO-CPS toolchain distribution.
 * GNU version 3 is obtained from: http://www.gnu.org/copyleft/gpl.html.
 *
 * This program is distributed WITHOUT ANY WARRANTY; without
 * even the implied warranty of  MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE, EXCEPT AS EXPRESSLY SET FORTH IN THE
 * BY RECIPIENT SELECTED SUBSIDIARY LICENSE CONDITIONS OF
 * THE INTO-CPS ASSOCIATION.
 *
 * See the full INTO-CPS Association Public License conditions for more details.
 */

/**
 * 2.1.7 Getting and Setting Variable Values
 */
functions
	/**
	 * The general contracts for calling fmi3GetXXX and fmi3SetXXX functions in a given state.
	 */
	generalGetPrecondition: fmi3Instance * seq of fmi3ValueReference +> bool
	generalGetPrecondition(c, vrs) ==
		cases c.fmuState:
			<INSTANTIATED>				-> false,
			<INITIALIZATION>			-> varsINIT(c, vrs),
			<CONFIGURATION_MODE>		-> true,
			<EVENT_MODE>				-> true,
			<CONTINUOUS_TIME_MODE>		-> true,
			<RECONFIGURATION_MODE>		-> true,
			<STEP_MODE>					-> true,
			<INTERMEDIATE_UPDATE_MODE>	-> false,
			<STEP_DISCARDED>			-> true,
			<TERMINATED>				-> true,
			<ERROR>						-> true,

			others -> undefined
		end;

	generalSetPrecondition: fmi3Instance * seq of fmi3ValueReference +> bool
	generalSetPrecondition(c, vrs) ==
		if c.fmuType = <fmi3ModelExchange>
		then
			cases c.fmuState:
				<INSTANTIATED>			-> varsSEA(c, vrs),
				<INITIALIZATION>		-> varsSE(c, vrs),
				<EVENT_MODE>			-> varsIN(c, vrs) or varsINC(c, vrs),
				<CONTINUOUS_TIME_MODE>	-> varsINC(c, vrs),
				<TERMINATED>			-> false,
				<ERROR>					-> false,

				others -> undefined
			end
		else	-- fmi3CoSimulation
			cases c.fmuState:
				<INSTANTIATED>				-> varsINI(c, vrs),
				<INITIALIZATION>			-> varsIN(c, vrs) or varsINI(c, vrs),
				<STEP_MODE>					-> varsIN(c, vrs),
				<INTERMEDIATE_UPDATE_MODE>	-> false,
				<STEP_DISCARDED>			-> false,
				<TERMINATED>				-> false,
				<ERROR>						-> false,

				others -> undefined
			end;

	/**
	 * Calculate the total number of values (possibly array cells) for a sequence of vrefs
	 */
	totalValues: fmi3Instance * seq1 of fmi3ValueReference +> nat
	totalValues(c, vrs) ==
		sum([ let sv = lookup(c.eModelVariables, vr) in
				dimensionsProduct(c.eModelVariables, sv.base.dimensions) | vr in seq vrs ]);

	/**
	 * Implementation and API for fmi3GetFloatXX.
	 */
	fmi3GetReal_Impl: fmi3Instance * FloatKind * seq of fmi3ValueReference * nat * nat +> fmi3Status * [seq of fmi3Float]
	fmi3GetReal_Impl(c, kind, vrs, nvr, nval) ==
		let mk_(s, c2) = /* if c.dirty then c.calculateValues(c) else */ mk_(<fmi3OK>, c) in
			if s <> <fmi3OK>
			then mk_(s, nil)
			else mk_(<fmi3OK>, [ c2.variables(c2.aliasMap(aliasTag(lookup(c.eModelVariables, vr)))) | vr in seq vrs ])
	pre
		len vrs = nvr
		and generalGetPrecondition(c, vrs)
		and (forall vr in seq vrs &
			exists v in seq c.eModelVariables & v.base.valueReference = vr and v.kind = kind)
		and nval = totalValues(c, vrs)
	post
		RESULT.#1 = <fmi3OK> => len RESULT.#2 = nval;

	fmi3GetReal: fmi3Instance * FloatKind * seq of fmi3ValueReference * nat * nat +> fmi3Status * [seq of fmi3Float]
	fmi3GetReal(c, kind, vrs, nvr, nval) ==
		if len vrs <> nvr
		then -- @Printf("vrs and nvr do not match\n")
			mk_(<fmi3Error>, nil)
		elseif not generalGetPrecondition(c, vrs)
		then -- @Printf("Get preconditions failed\n")
			mk_(<fmi3Error>, nil)
		elseif exists vr in seq vrs &
			(not exists v in seq c.eModelVariables & v.base.valueReference = vr and v.kind = kind)
		then -- @Printf("Value references are not all %s variables\n", kind)
			mk_(<fmi3Error>, nil)
		elseif nval <> totalValues(c, vrs)
		then -- @Printf("nValues (%s) does not match valueReference dimensions (%s)\n", nval, totalValues(c, vrs))
			mk_(<fmi3Error>, nil)
		else
			fmi3GetReal_Impl(c, kind, vrs, nvr, nval)
	post
	 	RESULT.#1 = <fmi3OK> <=> RESULT.#2 <> nil;

	fmi3GetFloat64: fmi3Instance * seq of fmi3ValueReference * nat * nat +> fmi3Status * [seq of fmi3Float]
	fmi3GetFloat64(c, vrs, nvr, nval) ==
		fmi3GetReal(c, <Float64>, vrs, nvr, nval)
	post
		RESULT.#1 = <fmi3OK> =>
			let mk_(min, max) = minMaxKind(<Float64>) in
				forall f in seq RESULT.#2 & min <= f and f <= max;

	fmi3GetFloat32: fmi3Instance * seq of fmi3ValueReference * nat * nat +> fmi3Status * [seq of fmi3Float]
	fmi3GetFloat32(c, vrs, nvr, nval) ==
		fmi3GetReal(c, <Float32>, vrs, nvr, nval)
	post
		RESULT.#1 = <fmi3OK> =>
			let mk_(min, max) = minMaxKind(<Float32>) in
				forall f in seq RESULT.#2 & min <= f and f <= max;
