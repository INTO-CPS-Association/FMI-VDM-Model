/**
 * This file is part of the INTO-CPS toolchain.
 *
 * Copyright (c) 2017-2019, INTO-CPS Association,
 * c/o Professor Peter Gorm Larsen, Department of Engineering
 * Finlandsgade 22, 8200 Aarhus N.
 *
 * All rights reserved.
 *
 * THIS PROGRAM IS PROVIDED UNDER THE TERMS OF GPL VERSION 3 LICENSE OR
 * THIS INTO-CPS ASSOCIATION PUBLIC LICENSE VERSION 1.0.
 * ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS PROGRAM CONSTITUTES
 * RECIPIENT'S ACCEPTANCE OF THE OSMC PUBLIC LICENSE OR THE GPL 
 * VERSION 3, ACCORDING TO RECIPIENTS CHOICE.
 *
 * The INTO-CPS toolchain  and the INTO-CPS Association Public License are
 * obtained from the INTO-CPS Association, either from the above address, from
 * the URLs: http://www.into-cps.org, and in the INTO-CPS toolchain distribution.
 * GNU version 3 is obtained from: http://www.gnu.org/copyleft/gpl.html.
 *
 * This program is distributed WITHOUT ANY WARRANTY; without
 * even the implied warranty of  MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE, EXCEPT AS EXPRESSLY SET FORTH IN THE
 * BY RECIPIENT SELECTED SUBSIDIARY LICENSE CONDITIONS OF
 * THE INTO-CPS ASSOCIATION.
 *
 * See the full INTO-CPS Association Public License conditions for more details.
 */

/**
 * 2.1.7 Getting and Setting Variable Values
 */
functions
	/**
	 * The general contracts for calling fmi3GetXXX and fmi3SetXXX functions in a given state.
	 */
	generalGetPrecondition: fmi3Instance * seq of fmi3ValueReference +> bool
	generalGetPrecondition(c, vrs) ==
		cases c.fmuKind:
			<ModelExchange> ->
				cases c.fmuState:
					<INSTANTIATED>				-> false,
					<CONFIGURATION_MODE>		-> false,
					<INITIALIZATION_MODE>		-> note1(c, vrs),
					<EVENT_MODE>				-> note2(c, vrs),
					<CONTINUOUS_TIME_MODE>		-> note2(c, vrs),
					<RECONFIGURATION_MODE>		-> false,
					<TERMINATED>				-> true,
					<ERROR>						-> true,

					others -> undefined
				end,

			<BasicCoSimulation>	->
				cases c.fmuState:
					<INSTANTIATED>				-> true,
					<CONFIGURATION_MODE>		-> true,
					<INITIALIZATION_MODE>		-> note12(c, vrs),
					<STEP_MODE>					-> true,
					<RECONFIGURATION_MODE>		-> false,
					<INTERMEDIATE_UPDATE_MODE>	-> note10(c, vrs),
					<TERMINATED>				-> true,

					others -> undefined
				end,

			<HybridCoSimulation> ->
				cases c.fmuState:
					<INSTANTIATED>				-> true,
					<CONFIGURATION_MODE>		-> true,
					<INITIALIZATION_MODE>		-> true,
					<STEP_MODE>					-> true,
					<RECONFIGURATION_MODE>		-> true,
					<INTERMEDIATE_UPDATE_MODE>	-> false,
					<TERMINATED>				-> true,

					others -> undefined
				end,

			<ScheduledCoSimulation> ->
				cases c.fmuState:
					<INSTANTIATED>				-> true,
					<CONFIGURATION_MODE>		-> true,
					<INITIALIZATION_MODE>		-> true,
					<CLOCK_ACTIVATION_MODE>		-> true,
					<RECONFIGURATION_MODE>		-> false,
					<INTERMEDIATE_UPDATE_MODE>	-> note13(c, vrs),
					<TERMINATED>				-> true,

					others -> undefined
				end,

			others -> undefined
		end;

	generalSetPrecondition: fmi3Instance * seq of fmi3ValueReference +> bool
	generalSetPrecondition(c, vrs) ==
		cases c.fmuKind:
			<ModelExchange> ->
				cases c.fmuState:
					<INSTANTIATED>				-> note4(c, vrs),
					<CONFIGURATION_MODE>		-> note5(c, vrs),
					<INITIALIZATION_MODE>		-> note3(c, vrs),
					<EVENT_MODE>				-> true,
					<CONTINUOUS_TIME_MODE>		-> true,
					<RECONFIGURATION_MODE>		-> note6(c, vrs),
					<TERMINATED>				-> true,
					<ERROR>						-> true,

					others -> undefined
				end,

			<BasicCoSimulation>	->
				cases c.fmuState:
					<INSTANTIATED>				-> note7(c, vrs),
					<CONFIGURATION_MODE>		-> note11(c, vrs),
					<INITIALIZATION_MODE>		-> note8(c, vrs),
					<STEP_MODE>					-> note9(c, vrs),
					<RECONFIGURATION_MODE>		-> note10(c, vrs),
					<INTERMEDIATE_UPDATE_MODE>	-> true,
					<TERMINATED>				-> true,

					others -> undefined
				end,

			<HybridCoSimulation> ->
				cases c.fmuState:
					<INSTANTIATED>				-> note7(c, vrs),
					<CONFIGURATION_MODE>		-> note11(c, vrs),
					<INITIALIZATION_MODE>		-> note8(c, vrs),
					<STEP_MODE>					-> note9(c, vrs),
					<EVENT_MODE>				-> note10(c, vrs),
					<INTERMEDIATE_UPDATE_MODE>	-> false,
					<RECONFIGURATION_MODE>		-> note10(c, vrs),
					<TERMINATED>				-> true,

					others -> undefined
				end,

			<ScheduledCoSimulation> ->
				cases c.fmuState:
					<INSTANTIATED>				-> true,
					<CONFIGURATION_MODE>		-> true,
					<INITIALIZATION_MODE>		-> true,
					<CLOCK_ACTIVATION_MODE>		-> true,
					<RECONFIGURATION_MODE>		-> note13(c, vrs),
					<INTERMEDIATE_UPDATE_MODE>	-> note14(c, vrs),
					<TERMINATED>				-> true,

					others -> undefined
				end,

			others -> undefined
		end;

	/**
	 * Calculate the total number of values (possibly array cells) for a sequence of vrefs
	 */
	totalValues: fmi3Instance * seq1 of fmi3ValueReference +> nat
	totalValues(c, vrs) ==
		sum([ len c.variables(vr) | vr in seq vrs ]);


	/**
	 * Implementation and API for fmi3GetFloatXX.
	 */
	fmi3GetReal_Impl: fmi3Instance * FloatKind * seq of fmi3ValueReference * nat * nat +> fmi3Status * [seq of fmi3Float]
	fmi3GetReal_Impl(c, kind, vrs, nvr, nval) ==
		let mk_(s, c2) = /* if c.dirty then c.calculateValues(c) else */ mk_(<fmi3OK>, c) in
			if s <> <fmi3OK>
			then mk_(s, nil)
			else mk_(<fmi3OK>, conc [ c2.variables(vr) | vr in seq vrs ])
	pre
		len vrs = nvr
		and generalGetPrecondition(c, vrs)
		and (forall vr in seq vrs &
			exists v in seq c.eModelVariables & v.base.valueReference = vr and v.kind = kind)
		and nval = totalValues(c, vrs)
	post
		RESULT.#1 = <fmi3OK> => len RESULT.#2 = nval
			and let mk_(min, max) = minMaxKind(kind) in
				forall f in seq RESULT.#2 & min <= f and f <= max;

	fmi3GetReal: fmi3Instance * FloatKind * seq of fmi3ValueReference * nat * nat +> fmi3Status * [seq of fmi3Float]
	fmi3GetReal(c, kind, vrs, nvr, nval) ==
		if len vrs <> nvr
		then let - = logAPIError(c, "vrs and nvr do not match") in
			mk_(<fmi3Error>, nil)

		elseif not generalGetPrecondition(c, vrs)
		then let - = logAPIError(c, "Get preconditions failed") in
			mk_(<fmi3Error>, nil)

		elseif exists vr in seq vrs &
			(not exists v in seq c.eModelVariables & v.base.valueReference = vr and v.kind = kind)
		then let - = logAPIError(c, "Value references are not all defined for kind") in
			mk_(<fmi3Error>, nil)

		elseif nval <> totalValues(c, vrs)
		then let - = logAPIError(c, "nValues does not match total valueReference dimensions") in
			mk_(<fmi3Error>, nil)

		else
			fmi3GetReal_Impl(c, kind, vrs, nvr, nval)
	post
	 	RESULT.#1 = <fmi3OK> <=> RESULT.#2 <> nil;

	fmi3GetFloat64: fmi3Instance * seq of fmi3ValueReference * nat * nat +> fmi3Status * [seq of fmi3Float]
	fmi3GetFloat64(c, vrs, nvr, nval) ==
		fmi3GetReal(c, <Float64>, vrs, nvr, nval);

	fmi3GetFloat32: fmi3Instance * seq of fmi3ValueReference * nat * nat +> fmi3Status * [seq of fmi3Float]
	fmi3GetFloat32(c, vrs, nvr, nval) ==
		fmi3GetReal(c, <Float32>, vrs, nvr, nval);


	/**
	 * Implementation and API for fmi3Get(U)IntXX.
	 */
	fmi3GetInteger_Impl: fmi3Instance * IntegerKind * seq of fmi3ValueReference * nat * nat +> fmi3Status * [seq of fmi3Integer]
	fmi3GetInteger_Impl(c, kind, vrs, nvr, nval) ==
		let mk_(s, c2) = /* if c.dirty then c.calculateValues(c) else */ mk_(<fmi3OK>, c) in
			if s <> <fmi3OK>
			then mk_(s, nil)
			else mk_(<fmi3OK>, conc [ c2.variables(vr) | vr in seq vrs ])
	pre
		len vrs = nvr
		and generalGetPrecondition(c, vrs)
		and (forall vr in seq vrs &
			exists v in seq c.eModelVariables & v.base.valueReference = vr and v.kind = kind)
		and nval = totalValues(c, vrs)
	post
		RESULT.#1 = <fmi3OK> => len RESULT.#2 = nval
	 		and let mk_(min, max) = minMaxKind(kind) in
				forall f in seq RESULT.#2 & min <= f and f <= max;

	fmi3GetInteger: fmi3Instance * IntegerKind * seq of fmi3ValueReference * nat * nat +> fmi3Status * [seq of fmi3Integer]
	fmi3GetInteger(c, kind, vrs, nvr, nval) ==
		if len vrs <> nvr
		then let - = logAPIError(c, "vrs and nvr do not match") in
			mk_(<fmi3Error>, nil)

		elseif not generalGetPrecondition(c, vrs)
		then let - = logAPIError(c, "Get preconditions failed") in
			mk_(<fmi3Error>, nil)

		elseif exists vr in seq vrs &
			(not exists v in seq c.eModelVariables & v.base.valueReference = vr and v.kind = kind)
		then let - = logAPIError(c, "Value references are not all defined for kind") in
			mk_(<fmi3Error>, nil)

		elseif nval <> totalValues(c, vrs)
		then let - = logAPIError(c, "nValues does not match total valueReference dimensions") in
			mk_(<fmi3Error>, nil)

		else
			fmi3GetInteger_Impl(c, kind, vrs, nvr, nval)
	post
	 	RESULT.#1 = <fmi3OK> <=> RESULT.#2 <> nil;

	fmi3GetInt64: fmi3Instance * seq of fmi3ValueReference * nat * nat +> fmi3Status * [seq of fmi3Float]
	fmi3GetInt64(c, vrs, nvr, nval) ==
		fmi3GetInteger(c, <Int64>, vrs, nvr, nval);

	fmi3GetInt32: fmi3Instance * seq of fmi3ValueReference * nat * nat +> fmi3Status * [seq of fmi3Float]
	fmi3GetInt32(c, vrs, nvr, nval) ==
		fmi3GetInteger(c, <Int32>, vrs, nvr, nval);

	fmi3GetInt16: fmi3Instance * seq of fmi3ValueReference * nat * nat +> fmi3Status * [seq of fmi3Float]
	fmi3GetInt16(c, vrs, nvr, nval) ==
		fmi3GetInteger(c, <Int16>, vrs, nvr, nval);

	fmi3GetInt8: fmi3Instance * seq of fmi3ValueReference * nat * nat +> fmi3Status * [seq of fmi3Float]
	fmi3GetInt8(c, vrs, nvr, nval) ==
		fmi3GetInteger(c, <Int8>, vrs, nvr, nval);

	fmi3GetUInt64: fmi3Instance * seq of fmi3ValueReference * nat * nat +> fmi3Status * [seq of fmi3Float]
	fmi3GetUInt64(c, vrs, nvr, nval) ==
		fmi3GetInteger(c, <UInt64>, vrs, nvr, nval);

	fmi3GetUInt32: fmi3Instance * seq of fmi3ValueReference * nat * nat +> fmi3Status * [seq of fmi3Float]
	fmi3GetUInt32(c, vrs, nvr, nval) ==
		fmi3GetInteger(c, <UInt32>, vrs, nvr, nval);

	fmi3GetUInt16: fmi3Instance * seq of fmi3ValueReference * nat * nat +> fmi3Status * [seq of fmi3Float]
	fmi3GetUInt16(c, vrs, nvr, nval) ==
		fmi3GetInteger(c, <UInt16>, vrs, nvr, nval);

	fmi3GetUInt8: fmi3Instance * seq of fmi3ValueReference * nat * nat +> fmi3Status * [seq of fmi3Float]
	fmi3GetUInt8(c, vrs, nvr, nval) ==
		fmi3GetInteger(c, <UInt8>, vrs, nvr, nval);
