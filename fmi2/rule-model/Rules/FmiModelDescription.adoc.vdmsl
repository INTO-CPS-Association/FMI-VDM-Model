--
-- Document created from FmiModelDescription.adoc at Thu Jan 11 21:03:23 GMT 2024
--
functions
----
validModelAttributes: FmiModelDescription +> bool
validModelAttributes(md) ==
	-- @OnFail(1000, "%NAME: ModelAttribute fmiVersion should be 2.0")
	( md.fmiVersion in set { "2.0" } );
----
----
validVendorAnnotations:FmiModelDescription +> bool
validVendorAnnotations(fmd) ==
	let tools = fmd.vendorAnnotations in
		tools <> nil =>
			/* @OnFail(1250, "2.2.6 VendorAnnotations tool names are not unique: %s",
				{ tools(a) | a, b in set inds tools &
					a <> b and tools(a) = tools(b) }) */
			( card { name | name in seq tools } = len tools );
----
----
validModelTypes: FmiModelDescription +> bool
validModelTypes(fmd) ==
	-- @OnFail("%NAME: At least one of ModelExchange, CoSimulation or ScheduledExecution must be set")
	( fmd.modelExchange <> nil or fmd.coSimulation <> nil );
----
----
validGenerationDateAndTime: FmiModelDescription +> bool
validGenerationDateAndTime(fmd) ==
	-- @OnFail("%NAME: generationDateAndTime should be YYYY-MM-DDThh:mm:ssZ at %s",
	-- loc2str(fmd.location))
	( fmd.generationDateAndTime <> nil => iso8601(fmd.generationDateAndTime) );
----
----
validTypeUnits: FmiModelDescription +> bool
validTypeUnits(fmd) ==
	fmd.typeDefinitions <> nil => allOf
	([
		tdef.unit <> nil =>
			-- @OnFail("%NAME: Type %s, unit %s not defined in UnitDefinitions at %s",
			-- tdef.name, tdef.unit, loc2str(tdef.location))
			( fmd.unitDefinitions <> nil
				and exists u in seq fmd.unitDefinitions & u.name = tdef.unit )

		| tdef in seq fmd.typeDefinitions & is_Real(tdef)
	]);
----
----
validVariableTypes: FmiModelDescription +> bool
validVariableTypes(fmd) == allOf
	([
		mv.fmi2ScalarVariable.declaredType <> nil =>
		let tdef = lookupType(mv.fmi2ScalarVariable.declaredType, fmd.typeDefinitions) in
			-- @OnFail("%NAME: %s type %s not found at %s",
			-- mv.name, mv.declaredType, loc2str(mv.location))
			( tdef <> nil )

			-- @OnFail("%NAME: %s type %s mismatch at %s",
			-- mv.name, mv.declaredType, loc2str(mv.location))
			and ( kindOf(tdef.fmi2SimpleType) = kindOf(mv.fmi2ScalarVariable) )

		| mv in seq fmd.modelVariables
	]);
----
----
validTypeNames: FmiModelDescription +> bool
validTypeNames(fmd) == fmd.typeDefinitions <> nil => allOf
	([
		-- @OnFail("%NAME: TypeDefinition and Variable names overlap: %s at %s",
		-- tdef.name, loc2str(tdef.location))
		( not exists mv in seq fmd.modelVariables & mv.name = tdef.name )

		| tdef in seq fmd.typeDefinitions
	]);
----
----
validVariableNames: FmiModelDescription +> bool
validVariableNames(fmd) ==
	fmd.variableNamingConvention = <structured> => allOf(conc
	[
		[
			-- @OnFail("%NAME: Structured name %s invalid at %s", mv.name, loc2str(mv.location))
			( validStructuredName(mv.name) ),

			-- @OnFail("%NAME: Name %s is not Float at %s", mv.name, loc2str(mv.location))
			( mv.name(1, ..., 4) = "der(" => is_Real(mv) )
		]

		| mv in seq fmd.modelVariables
	]);
----
----
validStart: FmiModelDescription * ModelVariables +> bool
validStart(-, evs) == allOf
	([
		let type = ev.fmi2ScalarVariable in
		[
			type.start <> nil =>
				-- @OnFail("%NAME: all start values must be between %s and %s at %s",
				-- ev.min, ev.max, ev.location)
				( type.min <= type.start and type.max >= type.start ),

			type.start = nil and ev.initial <> <calculated> =>
				-- @OnFail("%NAME: Warning: implicit start of 0 not within min/max at %s",
				-- ev.location)
				( (type.min <> nil => type.min <= 0) and
				  (type.max <> nil => type.max >= 0) ) or true	-- NOTE warning
		]

		| ev in seq evs & is_NumericKind(kindOf(ev.fmi2ScalarVariable))
	]);
----
----
validMinMax: FmiModelDescription * ModelVariables +> bool
validMinMax(-, evs) == allOf
	([
		let type = ev.fmi2ScalarVariable,
			mk_(kmin, kmax) = minMaxOfKind(kindOf(type)) in
		[
			-- @OnFail("%NAME: max %s is not a valid value of this type", type.max)
			( type.max <= kmax and type.max >= kmin ),

			-- @OnFail("%NAME: min %s is not a valid value of this type", type.min)
			( type.min <= kmax and type.min >= kmin ),

			-- @OnFail("%NAME: max %s not >= min %s", type.max, type.min)
			( type.max >= type.min )
		]

		| ev in seq evs & is_NumericKind(kindOf(ev.fmi2ScalarVariable))
	]);
----
----
validMultipleSets: FmiModelDescription * ModelVariables +> bool
validMultipleSets(fmd, evs) == allOf
	([
		ev.canHandleMultipleSetPerTimeInstant = true =>
			-- @OnFail("%NAME: Variable %s, canHandleMultipleSetPerTimeInstant invalid at %s",
			-- ev.name, loc2str(ev.location))
			( fmd.modelExchange <> nil and ev.causality = <input> )

		| ev in seq evs
	]);
----
----
validReinits: FmiModelDescription +> bool
validReinits(fmd) == allOf
	([
		is_Real(mv.fmi2ScalarVariable) and mv.fmi2ScalarVariable.reinit <> nil =>
			-- @OnFail("%NAME: %s, Real reinit for model exchange continuous time only at %s",
			-- mv.name, loc2str(mv.location))
			( isContinuousTimeState(mv.valueReference, fmd.modelVariables) and fmd.modelExchange <> nil )

		| mv in seq fmd.modelVariables
	]);
----
----
validVariableUnits: FmiModelDescription * ModelVariables +> bool
validVariableUnits(fmd, evs) == allOf
([
	is_Real(sv.fmi2ScalarVariable) => allOf
	([
		-- @OnFail(1019, "2.2.7 ScalarVariable %s, Real unit must be defined for displayUnit %s at %s",
		--	sv.name, sv.fmi2ScalarVariable.displayUnit, loc2str(sv.location))
		( sv.fmi2ScalarVariable.displayUnit <> nil => sv.fmi2ScalarVariable.unit <> nil ),

		sv.fmi2ScalarVariable.unit <> nil =>
			-- @OnFail(1020, "2.2.7 ScalarVariable %s, Real unit %s not defined in UnitDefinitions at %s",
			--	sv.name, sv.fmi2ScalarVariable.unit, loc2str(sv.location))
			( fmd.unitDefinitions <> nil
				and exists u in seq fmd.unitDefinitions & u.name = sv.fmi2ScalarVariable.unit )
	])

	| sv in seq evs
]);

----
----
validOutputs: FmiModelDescription * ModelVariables +> bool
validOutputs(fmd, evs) ==
	let outputIndexes = { svi | svi in set inds evs & evs(svi).causality = <output> } in
		if outputIndexes <> {}
		then
			-- @OnFail(1022, "2.2.8 Output variables but no outputs declared at %s",
			--	loc2str(fmd.modelStructure.location))
			( fmd.modelStructure.outputs <> nil )

			and let structIndexes = { u.index | u in seq fmd.modelStructure.outputs } in allOf
			([

				-- @OnFail(1023, "2.2.8 Outputs section does not match output variables at %s",
				--	loc2str(fmd.modelStructure.location))
				( structIndexes = outputIndexes ),

				-- @OnFail(1024, "2.2.8 Output indexes out of range at %s",
				--	loc2str(fmd.modelStructure.location))
				( forall i in set structIndexes & i <= len evs )
			])
		else
			/* @OnFail(1025, "2.2.8 Outputs should be omitted at %s",
				loc2str(fmd.modelStructure.location)) */
			( fmd.modelStructure.outputs = nil );
----
----
validDerivatives: FmiModelDescription * ModelVariables +> bool
validDerivatives(fmd, evs) ==
	fmd.modelExchange <> nil
	or (fmd.coSimulation <> nil and fmd.coSimulation.providesDirectionalDerivative = true) =>
		fmd.modelStructure.derivatives <> nil => allOf
		([
			-- @OnFail(1026, "2.2.8 Derivative index out of range at %s", loc2str(u.location))
			( u.index <= len evs )

			and let sv = evs(u.index) in allOf
			([
				-- @OnFail(1027, "2.2.8 SV not a state derivative at %s", loc2str(u.location))
				( isStateDerivative(sv) ),

				-- @OnFail(1028, "2.2.8 Derivative must be continuous at %s", loc2str(u.location))
				( u.dependencies <> nil => sv.variability = <continuous> )
			])

			| u in seq fmd.modelStructure.derivatives
		]);
----
----
validInitialUnknowns: FmiModelDescription * ModelVariables +> bool
validInitialUnknowns(fmd, evs) ==
	let ctVars = continuousTimeStates(evs),
		sdVars = stateDerivatives(evs),
		initIndexes = { svi | svi in set inds evs &
			let sv = evs(svi) in
				(sv.causality = <output>
					and sv.initial in set { <approx>, <calculated> })

				or (sv.causality = <calculatedParameter>)

				or (sv in set ctVars
					and sv.initial in set { <approx>, <calculated> })

				or (sv in set sdVars
					and sv.initial in set { <approx>, <calculated> }) }
	in
		initIndexes <> {} =>
			let ius = fmd.modelStructure.initialUnknowns in allOf
			([
				-- @OnFail(1029, "2.2.8 InitialUnknowns must include: %s", initIndexes)
				( ius <> nil ),

				-- @OnFail(1030, "2.2.8 InitialUnknowns must not include: %s",
				-- { u.index | u in seq ius } \ initIndexes )
				( ius <> nil => { u.index | u in seq ius } subset initIndexes ),

				-- @OnFail(1031, "2.2.8 InitialUnknowns are not sorted: %s",
				-- [ u.index | u in seq ius ])
				( ius <> nil => 
						forall i in set inds ius &
							i = len ius or ius(i).index < ius(i+1).index )
			]);
----

values
	FmiModelDescription_refs : ReferenceMap =
	{
		"validModelTypes" |->
		[
			"<FMI3_STANDARD>#table-schema-fmiModelDescription"
		],

		"validGenerationDateAndTime" |->
		[
			"<FMI3_STANDARD>#table-schema-fmiModelDescription-attributes"
		],

		"validTypeUnits" |->
		[
			"<FMI3_STANDARD>#table-type-details"
		],

		"validVariableTypes" |->
		[
			"<FMI3_STANDARD>#ModelVariables",
			"<FMI3_STANDARD>#definition-of-types"
		],

		"validTypeNames" |->
		[
			"<FMI3_STANDARD>#table-type-details"
		],

		"validVariableNames" |->
		[
			"<FMI3_STANDARD>#ModelVariables"
		],

		"validStart" |->
		[
			"<FMI3_STANDARD>#table-type-attributes"
		],

		"validMinMax" |->
		[
			"<FMI3_STANDARD>#table-type-attributes"
		],

		"validMultipleSets" |->
		[
			"<FMI3_STANDARD>#table-variableBase-attributes"
		],

		"validReinits" |->
		[
			"<FMI3_STANDARD>#ModelVariables"
		],

		"validCSEventMode" |->
		[
			"<FMI3_STANDARD>#table-CoSimulation-details"
		],

		"validOutput" |->
		[
			"<FMI3_STANDARD>#ModelStructure"
		],

		"validStateDerivatives" |->
		[
			"<FMI3_STANDARD>#ModelStructure"
		],
		
		"validInitialUnknowns" |->
		[
			"<FMI3_STANDARD>#ModelStructure"
		],
		
		"validEventIndicators" |->
		[
			"<FMI3_STANDARD>#ModelStructure"
		],
		
		"validOutputReferences" |->
		[
			"<FMI3_STANDARD>#ModelStructure"
		],
		
		"validUnknownDependencies" |->
		[
			"<FMI3_STANDARD>#ModelStructure"
		],

		"validClockPriorities" |->
		[
			"<FMI3_STANDARD>#table-type-details"
		]
	};
