/**
 * This file is part of the INTO-CPS toolchain.
 *
 * Copyright (c) 2017-2019, INTO-CPS Association,
 * c/o Professor Peter Gorm Larsen, Department of Engineering
 * Finlandsgade 22, 8200 Aarhus N.
 *
 * All rights reserved.
 *
 * THIS PROGRAM IS PROVIDED UNDER THE TERMS OF GPL VERSION 3 LICENSE OR
 * THIS INTO-CPS ASSOCIATION PUBLIC LICENSE VERSION 1.0.
 * ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS PROGRAM CONSTITUTES
 * RECIPIENT'S ACCEPTANCE OF THE OSMC PUBLIC LICENSE OR THE GPL 
 * VERSION 3, ACCORDING TO RECIPIENTS CHOICE.
 *
 * The INTO-CPS toolchain  and the INTO-CPS Association Public License are
 * obtained from the INTO-CPS Association, either from the above address, from
 * the URLs: http://www.into-cps.org, and in the INTO-CPS toolchain distribution.
 * GNU version 3 is obtained from: http://www.gnu.org/copyleft/gpl.html.
 *
 * This program is distributed WITHOUT ANY WARRANTY; without
 * even the implied warranty of  MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE, EXCEPT AS EXPRESSLY SET FORTH IN THE
 * BY RECIPIENT SELECTED SUBSIDIARY LICENSE CONDITIONS OF
 * THE INTO-CPS ASSOCIATION.
 *
 * See the full INTO-CPS Association Public License conditions for more details.
 */

/**
 * 2.2.3 Definition of Types (TypeDefinitions)
 */
types
	VariableType =
		Float32Type | Float64Type |
		Int64Type | Int32Type | Int16Type | Int8Type |
		UInt64Type | UInt32Type | UInt16Type | UInt8Type |
		BooleanType |
		StringType |
		BinaryType |
		EnumerationType |
		ClockType;

functions
	/**
	 * Check whether a type is a "real" type.
	 */
	isRealType: VariableType +> bool
	isRealType(var) ==
		is_Float64Type(var) or is_Float32Type(var);

	/**
	 * Check whether a type is an "integer" type.
	 */
	isIntegerType: VariableType +> bool
	isIntegerType(var) ==
		is_Int64Type(var) or is_Int32Type(var) or is_Int16Type(var) or is_Int8Type(var) or
		is_UInt64Type(var) or is_UInt32Type(var) or is_UInt16Type(var) or is_UInt8Type(var);


	isValidType: VariableType +> bool
	isValidType(stype) ==
		cases stype:
			mk_Float32Type(-, -, -, -, unit, dunit, -, -, min, max, -, -),
			mk_Float64Type(-, -, -, -, unit, dunit, -, -, min, max, -, -) ->
			{
				-- @OnFail(1150, "2.2.3 Type %s, Float max %s not >= min %s", stype.name, max, min)
				( max <> nil and min <> nil => max >= min ),

				-- @OnFail(1151, "2.2.3 Type %s, Real unit must be defined for displayUnit %s", stype.name, dunit)
				( dunit <> nil => unit <> nil )
			}
			union
			(
				let mk_(kmin, kmax) = minMaxKind(kindOf(stype)) in
				{
					max <> nil =>
						--@OnFail(1152, "2.2.3 max %s is not a valid value of this type", max)
						( max <= kmax and max >= kmin ),

					min <> nil =>
						--@OnFail(1153, "2.2.3 min %s is not a valid value of this type", min)
						( min <= kmax and min >= kmin )
				}
			)
			= {true},

			mk_Int64Type(-, -, -, -, min, max, -),
			mk_Int32Type(-, -, -, -, min, max, -),
			mk_Int16Type(-, -, -, -, min, max, -),
			mk_Int8Type(-, -, -, -, min, max, -),
			mk_UInt64Type(-, -, -, -, min, max, -),
			mk_UInt32Type(-, -, -, -, min, max, -),
			mk_UInt16Type(-, -, -, -, min, max, -),
			mk_UInt8Type(-, -, -, -, min, max, -) ->
			{
				-- @OnFail(1154, "2.2.3 Type %s, Integer max %s not >= min %s", stype.name, max, min)
				( max <> nil and min <> nil => max >= min )
			}
			union
			(
				let mk_(kmin, kmax) = minMaxKind(kindOf(stype)) in
				{
					max <> nil =>
						--@OnFail(1155, "2.2.3 max %s is not a valid value of this type", max)
						( max <= kmax and max >= kmin ),

					min <> nil =>
						--@OnFail(1156, "2.2.3 min %s is not a valid value of this type", min)
						( min <= kmax and min >= kmin )
				}
			)
			= {true},

			-- Items of an enumeration as a sequence of "name" and "value" pairs. The
			-- values can be any integer number, but must be unique within the same
			-- enumeration (in order that the mapping between "name" and "value" is
			-- bijective). An Enumeration element must have at least one Item.

			mk_EnumerationType(-, -, -, -, -, -, -, items) ->
				-- @OnFail(1157, "2.2.3 Type %s, Enumeration item name/values do not form a bijection", stype.name)
				(
					card { i.name | i in seq items } = len items
					and	card { i.value | i in seq items } = len items
				),

			others -> true		-- String, Boolean and Clock
		end;

	isValidTypeDefinitions: [seq of VariableType] +> bool
	isValidTypeDefinitions(defs) ==
		defs <> nil =>
			{
				/* @OnFail(1158, "2.2.3 TypeDefinitions names are not unique: %s",
					{ a.name | a, b in seq defs & a <> b and a.name = b.name }) */
				( card { stype.name | stype in seq defs } = len defs )
			}
			union
			{
				-- @OnFail(1159, "2.2.3 TypeDefinition %s invalid at %s", stype.name, loc2str(stype.location))
				( isValidType(stype) )

				| stype in seq defs
			} = {true};

