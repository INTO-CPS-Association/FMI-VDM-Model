/*********************************************************************************
 *
 *	Copyright (c) 2017-2022, INTO-CPS Association,
 *	c/o Professor Peter Gorm Larsen, Department of Engineering
 *	Finlandsgade 22, 8200 Aarhus N.
 *
 *	MIT Licence:
 *
 *	Permission is hereby granted, free of charge, to any person obtaining a copy of
 *	this software and associated documentation files (the "Software"), to deal in
 *	the Software without restriction, including without limitation the rights to use,
 *	copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 *	Software, and to permit persons to whom the Software is furnished to do so,
 *	subject to the following conditions:
 *
 *	The above copyright notice and this permission notice shall be included in all
 *	copies or substantial portions of the Software.
 *
 *	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 *	INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 *	PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 *	HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 *	OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 *	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *	SPDX-License-Identifier: MIT
 *
 *********************************************************************************/
types
	/**
	 * The invariant type for the top level FmiModelDescription.
	 */
	FmiModelDescription' = FmiModelDescription
	inv fmd == allOf
	([
		inv_ModelExchange'(fmd.modelExchange),
		inv_CoSimulation'(fmd.coSimulation),
		inv_ScheduledExecution'(fmd.scheduledExecution),
		inv_UnitDefinitions'(fmd.unitDefinitions),
		inv_TypeDefinitions'(fmd.typeDefinitions),
		inv_LogCategories'(fmd.logCategories),
		inv_DefaultExperiment'(fmd.defaultExperiment),
		inv_ModelStructure'(fmd.modelStructure),
		inv_Annotations'(fmd.annotations),

		-- If these rules use variables at all, they are the "raw" values
		rule("validGenerationDateAndTime", validGenerationDateAndTime(fmd)),
		rule("validModelTypes",	validModelTypes(fmd)),
		rule("validTypeUnits", validTypeUnits(fmd)),
		rule("vaidVariableTypes", validVariableTypes(fmd)),
		rule("validVariableNames", validVariableNames(fmd)),
		rule("validTypeNames", validTypeNames(fmd))
	]
	^ let evs = effectiveVariables(fmd.modelVariables, fmd.typeDefinitions) in
	[
		inv_ModelVariables'(evs),

		-- If these rules use variables, they use the effective values
		rule("validMultipleSets", validMultipleSets(fmd, evs)),
		rule("validClockPriorities", validClockPriorities(fmd, evs)),
		rule("validOutput", validOutput(fmd, evs)),
		rule("validStateDerivatives", validStateDerivatives(fmd, evs)),
		rule("validInitialUnknowns", validInitialUnknowns(fmd, evs)),
		rule("validEventIndicators", validEventIndicators(fmd, evs)),
		rule("validOutputReferences", validOutputReferences(fmd, evs)),
		rule("validUnknownDependencies", validUnknownDependencies(fmd, evs))
	]);

functions
	/**
	 * Check that at least one FMU type has been included.
	 */
	validModelTypes: FmiModelDescription +> bool
	validModelTypes(fmd) ==
		-- @OnFail("validModelTypes: At least one of ModelExchange, CoSimulation or ScheduledExecution must be set")
		( fmd.modelExchange <> nil or fmd.coSimulation <> nil or fmd.scheduledExecution <> nil );

	/**
	 * Check the format of the optional generationDateAndTime field.
	 */
	validGenerationDateAndTime: FmiModelDescription +> bool
	validGenerationDateAndTime(fmd) ==
		-- @OnFail("validGenerationDateAndTime: generationDateAndTime should be YYYY-MM-DDThh:mm:ssZ at %s", loc2str(fmd.location))
		( fmd.generationDateAndTime <> nil => iso8601(fmd.generationDateAndTime) );
	
	validTypeUnits: FmiModelDescription +> bool
	validTypeUnits(fmd) ==
		fmd.typeDefinitions <> nil => allOf
		([
			tdef.unit <> nil =>
				-- @OnFail("validTypeUnits: Type %s, unit %s not defined in UnitDefinitions at %s", tdef.name, tdef.unit, loc2str(tdef.location))
				( fmd.unitDefinitions <> nil
					and exists u in seq fmd.unitDefinitions & u.name = tdef.unit )

			| tdef in seq fmd.typeDefinitions & isFloat(tdef)
		]);

	validVariableTypes: FmiModelDescription +> bool
	validVariableTypes(fmd) == allOf
		([
			mv.declaredType <> nil => let tdef = lookupType(mv.declaredType, fmd.typeDefinitions) in
				-- @OnFail("validVariableTypes: %s type %s not found at %s", mv.name, mv.declaredType, loc2str(mv.location))
				( tdef <> nil )

				-- @OnFail("validVariableTypes: %s type %s mismatch at %s", mv.name, mv.declaredType, loc2str(mv.location))
				and ( kindOf(tdef) = kindOf(mv) )

			| mv in seq fmd.modelVariables
		]);

	validTypeNames: FmiModelDescription +> bool
	validTypeNames(fmd) == fmd.typeDefinitions <> nil => allOf
		([
			-- @OnFail("validTypeNames: TypeDefinition and Variable names overlap: %s at %s", tdef.name, loc2str(tdef.location))
			( not exists mv in seq fmd.modelVariables & mv.name = tdef.name )

			| tdef in seq fmd.typeDefinitions
		]);

	validVariableNames: FmiModelDescription +> bool
	validVariableNames(fmd) ==
		fmd.variableNamingConvention = <structured> => allOf(conc
		[
			[
				-- @OnFail("validVariableNames: Structured name %s invalid at %s", mv.name, loc2str(mv.location))
				( isValidStructuredName(mv.name) ),

				-- @OnFail("validVariableNames: Name %s is not Float at %s", mv.name, loc2str(mv.location))
				( mv.name(1, ..., 4) = "der(" => isFloat(mv) )
			]

			| mv in seq fmd.modelVariables
		]);

	validMultipleSets: FmiModelDescription * ModelVariables +> bool
	validMultipleSets(fmd, evs) == allOf
		([
			ev.canHandleMultipleSetPerTimeInstant =>
				-- @OnFail("validMultipleSets: Variable %s, canHandleMultipleSetPerTimeInstant invalid at %s", ev.name, loc2str(ev.location))
				( fmd.modelExchange <> nil and ev.causality = <input> )

			| ev in seq evs
		]);

	validReinits: FmiModelDescription +> bool
	validReinits(fmd) == allOf
		([
			isFloat(mv) and mv.reinit <> nil =>
				-- @OnFail("validReinits: Variable %s, Float reinit for model exchange continuous time only at %s", mv.name, loc2str(mv.location))
				( isContinuousTimeState(mv, fmd.modelVariables) and fmd.modelExchange <> nil )

			| mv in seq fmd.modelVariables
		]);


	validOutput: FmiModelDescription * ModelVariables +> bool
	validOutput(fmd, evs) ==
		let outputRefs = { sv.valueReference | sv in seq evs & sv.causality = <output> },
			structRefs = { u.valueReference | u in seq default[seq of Output](fmd.modelStructure.output, []) }
		in
			if outputRefs <> {}
			then
				-- @OnFail("validOutput: Output variables but no outputs declared at %s", loc2str(fmd.modelStructure.location))
				( structRefs <> {} )

				and
				-- @OnFail("validOutput: Outputs section does not match output variables at %s", loc2str(fmd.modelStructure.location))
				( structRefs = outputRefs )
			else
				-- @OnFail("validOutput: Outputs should be omitted at %s", loc2str(fmd.modelStructure.location))
				( structRefs = {} );

	validStateDerivatives: FmiModelDescription * ModelVariables +> bool
	validStateDerivatives(fmd, evs) ==
		fmd.modelExchange <> nil => allOf
		([
			let ev = lookupVariable(uk.valueReference, evs) in
				-- @OnFail("validStateDerivatives: Derivative valueReference unknown at %s", loc2str(uk.location))
				( ev <> nil )

				and allOf
				([
					-- @OnFail("validStateDerivatives: SV not a state derivative at %s", loc2str(uk.location))
					( isStateDerivative(ev) ),

					-- @OnFail("validStateDerivatives: Derivative must be continuous at %s", loc2str(uk.location))
					( uk.dependencies <> nil => ev.variability = <continuous> )
				])

			| uk in seq default[seq of ContinuousStateDerivative](fmd.modelStructure.continuousStateDerivative, [])
		]);

	validInitialUnknowns: FmiModelDescription * ModelVariables +> bool
	validInitialUnknowns(fmd, evs) ==
		let ctVars = continuousTimeStates(evs),
			sdVars = stateDerivatives(evs),
			required = { sv.valueReference | sv in seq evs &
				(sv.clocks = nil and sv.causality = <output>
					and not is_Clock(sv) and sv.initial in set { <approx>, <calculated> })

				or (sv.causality = <calculatedParameter>)

				or (sv in set ctVars
					and sv.initial in set { <approx>, <calculated> })

				or (sv in set sdVars
					and sv.initial in set { <approx>, <calculated> }) },
			optional = { sv.valueReference | sv in seq evs & sv.clocks <> nil },
			allIUs   = { iu.valueReference | iu in seq default[seq of InitialUnknown](fmd.modelStructure.initialUnknown, []) },
			allEIs   = { ei.valueReference | ei in seq default[seq of EventIndicator](fmd.modelStructure.eventIndicator, []) }
		in
			allOf
			([
				-- This may not be true!
				-- ?? @OnFail("validInitialUnknowns: InitialUnknowns must include refs: %s", required \ allIUs)
				-- ( required subset allIUs ),

				-- @OnFail("validInitialUnknowns: InitialUnknowns can only include refs: %s", required union optional)
				( allIUs subset required union optional ),

				-- @OnFail("validInitialUnknowns: InitialUnknowns cannot include EventIndicators: %s ", allIUs inter allEIs)
				( allIUs inter allEIs = {} ),

				-- @OnFail("validInitialUnknowns: InitialUnknowns must not have duplicates: %s")
				( card allIUs = len default[seq of InitialUnknown](fmd.modelStructure.initialUnknown, []) )
			]
			^
			[
				iu.dependencies <> nil and iu.dependencies <> [] =>
					-- @OnFail("validInitialUnknowns: InitialUnknown dependencies must all be known at %s", loc2str(iu.location))
					( forall d in seq iu.dependencies & d not in set allIUs )

				| iu in seq default[seq of InitialUnknown](fmd.modelStructure.initialUnknown, [])
			]);

	validEventIndicators: FmiModelDescription * ModelVariables +> bool
	validEventIndicators(fmd, evs) ==
		fmd.modelStructure.eventIndicator <> nil => allOf
		([
			-- @OnFail("validEventIndicators: EventIndicator valueReference %s invalid at %s", ei.valueReference, loc2str(ei.location))
			( exists sv in seq evs & sv.valueReference = ei.valueReference )

			| ei in seq fmd.modelStructure.eventIndicator
		]);

	validOutputReferences: FmiModelDescription * ModelVariables +> bool
	validOutputReferences(fmd, evs) ==
		fmd.modelStructure.output <> nil => allOf
		([
			-- @OnFail("validOutputReferences: Output valueReference %s is not an output at %s", ei.valueReference, loc2str(ei.location))
			( exists sv in seq evs &
				sv.valueReference = ei.valueReference and sv.causality = <output> )

			| ei in seq fmd.modelStructure.output
		]);

	validUnknownDependencies: FmiModelDescription * ModelVariables +> bool
	validUnknownDependencies(fmd, evs) ==
		let allUnknowns = conc
		[
			default[seq of Output](fmd.modelStructure.output, []),
			default[seq of ContinuousStateDerivative](fmd.modelStructure.continuousStateDerivative, []),
			default[seq of ClockedState](fmd.modelStructure.clockedState, []),
			default[seq of InitialUnknown](fmd.modelStructure.initialUnknown, []),
			default[seq of EventIndicator](fmd.modelStructure.eventIndicator, [])
		] in
			allUnknowns <> [] => allOf
			([
				unk.dependencies <> nil and unk.dependencies <> [] => allOf
				([
					-- @OnFail("validUnknownDependencies: Unknown dependency %s invalid at %s", vr, loc2str(unk.location))
					( exists sv in seq evs & sv.valueReference = vr )

					| vr in seq unk.dependencies
				])

				| unk in seq allUnknowns
			]);

	validClockPriorities: FmiModelDescription * ModelVariables +> bool
	validClockPriorities(fmd, evs) == allOf
		([
			if fmd.scheduledExecution <> nil then
				is_Clock(ev) =>
					if ev.causality = <input>
					then
						-- @OnFail("validClockPriorities: Input clock %s must have a priority for Scheduled Execution at %s", ev.name, loc2str(ev.location))
						( ev.priority <> nil )
					else
						-- @OnFail("validClockPriorities: Non-input clock %s must not have a priority for Scheduled Execution at %s", ev.name, loc2str(ev.location))
						( ev.priority = nil )
			else
				-- @OnFail("validClockPriorities: Clock %s must not have a priority unless Scheduled Execution at %s", ev.name, loc2str(ev.location))
				( is_Clock(ev) => ev.priority = nil )
				
			| ev in seq evs
		]);