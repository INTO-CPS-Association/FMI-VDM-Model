== Appendix A: Formal Static Semantics of FMI3

=== A.{counter:section} Introduction

The FMI Standard document contains a complete description of the semantics of the FMI API, and the structure of an FMU and its configuration files.

This document contains formally specified rules that clarify the textual description in the Standard. The formal rules can be used to automatically test the compliance of an FMU with the Standard, and rule violations give references back to the Standard where the issue is discussed. Similarly, links in the Standard refer to the rules given in this document.

The rules currently only cover the _static_ semantics of the Standard. That is, they describe the rules for correctly configured XML files. The dynamic semantics, defining the behaviour of the API, may be formally specified subsequently.

=== A.{counter:section} VDM-SL Specifications

The rules are defined in VDM-SL, the specification language of the https://en.wikipedia.org/wiki/Vienna_Development_Method[Vienna Development Method].  The language has a formal semantics, enabling proof of the properties of models to a high level of assurance. It also has an executable subset, so that real world data can be processed.

Free https://github.com/jonaskrask/vdm-vscode[open source tools] are available to process the VDM-SL rules.

=== A.{counter:section} Structure of the Rules

Each formal rule has a unique name and is associated with one XML type in the FMI Schema.

Rules are associated with the lowest level XML type that encapsulates all of the data involved. For example, the rule that Category names must be unique within LogCategories is  associated with the LogCategories type itself, since that includes all the Categories concerned. The rule that a TypeDefinition's unit names must be defined in the UnitDefinitions is associated with the top level FmiModelDescription type, since that type encompasses both TypeDefinitions and UnitDefinitions.

All rules are functions that return a boolean success/fail result. They are passed the record that contain the data to check. For example:

----
validTolerance: DefaultExperiment +> bool
validTolerance(e) ==
	-- @OnFail("validTolerance: tolerance must be >= 0 at %s", loc2str(e.location))
	( e.tolerance <> nil => e.tolerance >= 0 );
----

This defines a rule called "validTolerance" which is passed a DefaultExperiment record to test. The record is referred to by the name "e" within the body of the rule, which follows this header.

Rules contain _@OnFail_ comments, which define error messages associated with clauses in the rule. The comments themselves are not part of the rules and do not affect whether the rule succeeds or fails. All records have a "location" field added which contains the filename and line number of the data in the original XML. The _loc2str_ function turns locations into useful strings.

Rules sometimes use a function called _allOf_, which is passed a comma-separated list of boolean values in square brackets, all of which must be true for the overall rule to be met.

// This adds the "functions" section header for VDM only
ifdef::hidden[]
// {vdm}
functions
// {vdm}
endif::[]

=== A.{counter:section} Rules
==== A.{section}.{counter:subsection} SourceFileSet Rules
===== A.{section}.{subsection}.{counter:typerule} Rule: validCompilerOptions
[[validCompilerOptions]]
// {vdm}
----
validCompilerOptions: SourceFileSet +> bool
validCompilerOptions(sfs) ==
	-- @OnFail("validCompilerOptions: Compiler options set without compiler at %s", loc2str(sfs.location))
	( sfs.compilerOptions <> nil => sfs.compiler <> nil );
----
// {vdm}
See <<table-SourceFileSet-details>>.

===== A.{section}.{subsection}.{counter:typerule} Rule: validSourceFileNames
[[validSourceFileNames]]
// {vdm}
----
validSourceFileNames: SourceFileSet +> bool
validSourceFileNames(sfs) ==
	let files = sfs.sourceFile in
	let names = [ sf.name | sf in seq files ] in
		/* @OnFail("validSourceFilesName: SourceFileSet has duplicate names: %s",
			{ files(a) | a, b in set inds names & a <> b and files(a) = files(b) })	*/
		( card elems names = len names );
----
// {vdm}
See <<table-SourceFile-details>>.

===== A.{section}.{subsection}.{counter:typerule} Rule: validPreprocessorDefinitionNames
[[validPreprocessorDefinitionNames]]
// {vdm}
----
validPreprocessorDefinitionNames: SourceFileSet +> bool
validPreprocessorDefinitionNames(sfs) ==
	let defs = sfs.preprocessorDefinition in
	defs <> nil =>
		let names = [ d.name | d in seq defs ] in
			/* @OnFail("validPreprocessorDefinitionNames: PreprocessorDefinitions has duplicate names: %s",
				{ names(a) | a, b in set inds names & a <> b and names(a) = names(b) }) */
			( card elems names = len names );
----
// {vdm}
See <<table-ProcessorDefinition-details>>.

===== A.{section}.{subsection}.{counter:typerule} Rule: validIncludeDirectoryNames
[[validIncludeDirectoryNames]]
// {vdm}
----
validIncludeDirectoryNames: SourceFileSet +> bool
validIncludeDirectoryNames(sfs) ==
	let incs = sfs.includeDirectory in
	incs <> nil =>
		let names = [ d.name | d in seq incs ] in
			/* @OnFail("validIncludeDirectoryNames: IncludeDirectories has duplicate names: %s",
				{ names(a) | a, b in set inds names & a <> b and names(a) = names(b) }) */
			( card elems names = len names );
----
// {vdm}
See <<table-IncludeDirectory-details>>.

// This adds the docrefs for VDM only
ifdef::hidden[]
// {vdm}
values
	BuildConfiguration_refs : ReferenceMap =
	{
		"validCompilerOptions" |->
		[
			"fmi-standard/docs/index.html#table-SourceFileSet-details"
		],

		"validSourceFileNames" |->
		[
			"fmi-standard/docs/index.html#table-SourceFile-details"
		],

		"validPreprocessorDefinitionNames" |->
		[
			"fmi-standard/docs/index.html#table-ProcessorDefinition-details"
		],

		"validIncludeDirectoryNames" |->
		[
			"fmi-standard/docs/index.html#table-IncludeDirectory-details"
		]
	};

functions
// {vdm}
endif::[]

==== A.{section}.{counter:subsection} DefaultExperiment Rules
===== A.{section}.{subsection}.{counter:typerule} Rule: validTolerance
[[validTolerance]]
// {vdm}
----
validTolerance: DefaultExperiment +> bool
validTolerance(e) ==
	-- @OnFail("validTolerance: tolerance must be >= 0 at %s", loc2str(e.location))
	( e.tolerance <> nil => e.tolerance >= 0 );
----
// {vdm}
See <<DefaultExperiment>>.

===== A.{section}.{subsection}.{counter:typerule} Rule: validStartStopTime
[[validStartStopTime]]
// {vdm}
----
validStartStopTime: DefaultExperiment +> bool
validStartStopTime(e) ==
	-- @OnFail("validStartStopTime: stop time must be later than start time at %s", loc2str(e.location))
	( e.startTime <> nil and e.stopTime <> nil => e.stopTime > e.startTime );
----
// {vdm}
See <<DefaultExperiment>>.

===== A.{section}.{subsection}.{counter:typerule} Rule: validStepSize
[[validStepSize]]
// {vdm}
----
validStepSize: DefaultExperiment +> bool
validStepSize(e) ==
	-- @OnFail("validStepSize: stepSize must be less than start-stop interval at %s", loc2str(e.location))
	( e.startTime <> nil and e.stopTime <> nil and e.stepSize <> nil =>
		e.stopTime - e.startTime > e.stepSize );
----
// {vdm}
See <<DefaultExperiment>>.

// This adds the docrefs for VDM only
ifdef::hidden[]
// {vdm}
values
	DefaultExperiment_refs : ReferenceMap =
	{
		"validTolerance" |->
		[
			"fmi-standard/docs/index.html#DefaultExperiment"
		],

		"validStartStopTime" |->
		[
			"fmi-standard/docs/index.html#DefaultExperiment"
		],

		"validStepSize" |->
		[
			"fmi-standard/docs/index.html#DefaultExperiment"
		]
	};

functions
// {vdm}
endif::[]

==== A.{section}.{counter:subsection} CoSimulation Rules
===== A.{section}.{subsection}.{counter:typerule} Rule: validCSModelIdentifier
[[validCSModelIdentifier]]
// {vdm}
----
validCSModelIdentifier: CoSimulation +> bool
validCSModelIdentifier(cs) ==
	-- @OnFail("validCSModelIdentifier: %s not valid C variable name at %s", cs.modelIdentifier, loc2str(cs.location))
	( validIdentifier(cs.modelIdentifier) );
----
// {vdm}
- See <<modelIdentifier>>.
- See <<header-files-and-naming-of-functions>>.

// This adds the docrefs for VDM only
ifdef::hidden[]
// {vdm}
values
	CoSimulation_refs : ReferenceMap =
	{
		"validCSModelIdentifier" |->
		[
			"fmi-standard/docs/index.html#modelIdentifier",
			"fmi-standard/docs/index.html#header-files-and-naming-of-functions"
		]
	};

functions
// {vdm}
endif::[]


==== A.{section}.{counter:subsection} XXX Rules
===== A.{section}.{subsection}.{counter:typerule} Rule: YYY
[[YYY]]
// {vdm}
----

----
// {vdm}
See <<ref>>.

// This adds the docrefs for VDM only
ifdef::hidden[]
// {vdm}
values
	XXX_refs : ReferenceMap =
	{
		"YYY" |->
		[
			"fmi-standard/docs/index.html#YYY"
		]
	};

functions
// {vdm}
endif::[]
