== Formal Static Semantics of FMI3

=== Introduction

The FMI Standard document contains a complete description of the semantics of the FMI API, and the structure of an FMU and its configuration files.

This document contains formally specified rules that clarify the textual description in the Standard. The formal rules can be used to automatically test the compliance of an FMU with the Standard, and rule violations give references back to the Standard where the issue is discussed. Similarly, links in the Standard refer to the rules given in this document.

The rules currently only cover the _static_ semantics of the Standard. That is, they describe the rules for correctly configured XML files. The dynamic semantics, defining the behaviour of the API, may be formally specified subsequently.

=== VDM-SL Specifications

The rules are given in VDM-SL, the specification language of the https://en.wikipedia.org/wiki/Vienna_Development_Method>[Vienna Development Method].  The language has a formal semantics, enabling proof of the properties of models to a high level of assurance. It also has an executable subset, so that real world data can be processed.

Free, open source tools are available to process these rules.

=== Structure of the Rules

Each formal rule has a unique name and is associated with one XML type in the FMI Schema.

Rules are associated with the lowest level XML type that encapsulates all of the data involved. For example, the rule that Category names must be unique within LogCategories is  associated with the LogCategories type itself, since that includes all the Categories concerned. The rule that a TypeDefinition's unit names must be defined in the UnitDefinitions is associated with the top level FmiModelDescription type, since that type encompasses both TypeDefinitions and UnitDefinitions.

All rules are functions that return a boolean result. They are passed the record(s) that contain the data to check. For example:

----
validDefaultExperiment: DefaultExperiment +> bool
validDefaultExperiment(e) == ...
----

This defines a rule called "validDefaultExperiment" which is passed a DefaultExperiment record to test. The record is referred to by the name "e" within the body of the rule, which follows this header.

Rules contain _@OnFail_ comments, which define error messages associated with clauses in the rule. The comments themselves are not part of the rules and do not affect whether the rule succeeds or fails. All records have a "location" field added which contains the filename and line number of the data in the XML. The "loc2str" function used in @OnFail comments turns locations into useful strings.

Rules sometimes contain a function called _allOf_, which is passed a [...] comma-separated list of boolean values, all of which must be true for the overall rule to be met.

// This prefix adds the "functions" header for VDM only
ifdef::hidden[]
// {vdm}
functions
// {vdm}
endif::[]

==== DefaultExperiment

The validity of a DefaultExperiment record is defined as follows:

// {vdm}
----
validDefaultExperiment: DefaultExperiment +> bool
validDefaultExperiment(e) == allOf
([
	-- @OnFail("validDefaultExperiment: tolerance must be >= 0 at %s", loc2str(e.location))
	( e.tolerance <> nil => e.tolerance >= 0 ),

	-- @OnFail("validDefaultExperiment: stop time must be later than start time at %s", loc2str(e.location))
	( e.startTime <> nil and e.stopTime <> nil => e.stopTime > e.startTime ),

	-- @OnFail("validDefaultExperiment: stepSize must be less than start-stop interval at %s", loc2str(e.location))
	( e.startTime <> nil and e.stopTime <> nil and e.stepSize <> nil =>
		e.stopTime - e.startTime > e.stepSize )
]);
----
// {vdm}

