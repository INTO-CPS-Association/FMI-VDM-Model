/**
 * This file is part of the INTO-CPS toolchain.
 *
 * Copyright (c) 2017-2019, INTO-CPS Association,
 * c/o Professor Peter Gorm Larsen, Department of Engineering
 * Finlandsgade 22, 8200 Aarhus N.
 *
 * All rights reserved.
 *
 * THIS PROGRAM IS PROVIDED UNDER THE TERMS OF GPL VERSION 3 LICENSE OR
 * THIS INTO-CPS ASSOCIATION PUBLIC LICENSE VERSION 1.0.
 * ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS PROGRAM CONSTITUTES
 * RECIPIENT'S ACCEPTANCE OF THE OSMC PUBLIC LICENSE OR THE GPL 
 * VERSION 3, ACCORDING TO RECIPIENTS CHOICE.
 *
 * The INTO-CPS toolchain  and the INTO-CPS Association Public License are
 * obtained from the INTO-CPS Association, either from the above address, from
 * the URLs: http://www.into-cps.org, and in the INTO-CPS toolchain distribution.
 * GNU version 3 is obtained from: http://www.gnu.org/copyleft/gpl.html.
 *
 * This program is distributed WITHOUT ANY WARRANTY; without
 * even the implied warranty of  MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE, EXCEPT AS EXPRESSLY SET FORTH IN THE
 * BY RECIPIENT SELECTED SUBSIDIARY LICENSE CONDITIONS OF
 * THE INTO-CPS ASSOCIATION.
 *
 * See the full INTO-CPS Association Public License conditions for more details.
 */
 types
	/**
	 * A point in superdense time is represented by a real quantity and a whole
	 * number instant "within" that time.
	 */
	Time ::
		r	: real
		i	: nat
	inv t ==
		t.r >= 0	-- Times must be positive
	ord a < b ==
		(a.r < b.r) or (a.r = b.r and a.i < b.i);	-- NB using real equality!

	/**
	 * Possible "interval" values for a Clock variable
	 */
	Interval = <constant> | <fixed> | <calculated> | <tunable> | <changing> | <countdown> | <triggered>;

	FMUMode = <INIT> | <DONE> | <STEP> | <EVENT>;

	Contract = <none> | <reactive> | <delayed> ;

	PortType = <discrete> | <continous>; 

	Causality = <input> | <output>;
	/**
	 * The different types of actions
	 */
	ActionType = <get> | <set> | <step> | <getC> | <setC> ;  

	/*
		An FMU action has a type and some infomration describe the paramters of the actions
	*/
	Action ::
		actionType : ActionType
		fmu : Name
		port : Ref;
	

	/**
	 * A variable or clock reference. These are unique within an FMU.
	 */
	Ref = nat;

	/**
	 * A convenient way to name FMUs.
	 */
	Name = seq1 of char;

	/**
	 * A reference to a connection point in a specific named FMU.
	 */
	FMURef ::
		name	: Name
		ref		: Ref;

	/**
	 * The current known FMU variable values. These are usually used by FMUs, but note that
	 * Clocks can produce temporary environments that are not committed until a step.
	 */
	Environment = map Ref to Value;

	/**
	 * The value that a clock or variable can have. 
	 * It contains a time and a value
	 */
	Value ::
		value : real | int | bool
		time : Time;

	/**
	 * An Equation is used to modify the values of an FMU in order to compute a new
	 * step in time. A clock defines a set of equations to activate.
	 */
	Equation = Environment -> Environment;

	/**
	 * A variable is identified by a Ref (within an FMU).
	 */
	Variable ::
		ref			: Ref
        time        : Time
        causality	: Causality
        type		: PortType
		clocks		: set of Ref -- clocks that the variable can active
        dependsOn   : set of Ref -- feedthrough only relevant for outputs
        contract    : Contract 
	inv var ==
		(var.causality = <output> => var.contract = <none>) -- input contract only relevant for inputs
		and var.causality = <input> => var.dependsOn = {} ;


	/**
	 * A clock is identified by a Ref (within an FMU) and activates a set of equations.
	 */
	Clock ::
		ref			: Ref
		type		: Causality
		interval	: Interval
        timeToTick  : Time
		dependsOn 	: set of Ref -- The clocks that can trigger an clock
		equations	: set of Ref -- variables the clock activates
	inv clock ==
		(clock.type = <output> => clock.interval = <triggered>)	-- An output clock must be of type triggered 
		and (clock.type = <input> => clock.dependsOn = {}); -- Only output clocks are subject to feedthrough

	/**
	 * An FMU is comprised of a set of clocks and variables, plus an environment that holds
	 * the current values for both. The references must be unique and the references within
	 * the environment must all refer to known variables.
	 */
	FMU ::
		name				: Name				-- m
		clocks				: set of Clock		-- Ucm + Ycm
		inputs				: set of Variable	-- Um 
        outputs             : set of Variable   -- Ym
		mode				: FMUMode -- Mode of the FMU
		time				: Time				-- time is per FMU
        maxStep             : real				-- How far can the FMU step
		env					: Environment
		activeClocks		: set of Ref		-- 
		activeEquations		: set of Equation	-- I think this needs to be a set of reference
	inv fmu ==
		let vars = fmu.inputs union fmu.outputs in
		let crefs = { c.ref | c in set fmu.clocks },
			vrefs = { v.ref | v in set vars},
			refs  = crefs union vrefs
		in
            -- The maximal step cannot be negative
            fmu.maxStep >= 0.0
			-- All clock and variable references are unique
			and card refs = card fmu.clocks + card vars
			-- All references in the environment are defined
			and (dom fmu.env subset refs)
			-- All active clocks are defined
			and (fmu.activeClocks subset crefs)
			-- A clock can only be active when the fmu is in event mode
			and (fmu.mode <> <EVENT> => fmu.activeClocks = {})
			-- An equation can only be active when the fmu is in event mode
			and (fmu.mode <> <EVENT> => fmu.activeEquations = {})
			-- All variables' clocks are defined
			and (forall var in set vars & var.clocks subset crefs)
			-- An active variable is active by a clock Todo
			--and (forall (cref |-> val) in set fmu.activeEquations 
			---		& exists c in set fmu.clocks & c.ref in set fmu.activeClocks and equation in set c.equations)
			-- All scheduled clocks are defined
			;

	/**
	 * A machine is a collection of FMUs, plus a connection map between them. The connection
	 * sources must be FMU outputs and the destinations must be FMU inputs.
	 */
	Machine ::
		fmus				: map Name to FMU
		connections			: map FMURef to FMURef
		clockConnections	: map FMURef to FMURef
	inv m ==
		(forall srcRef in set dom m.connections &
			-- Every connection's source is a known FMU
			srcRef.name in set dom m.fmus
			-- Every connection's source is an output from its FMU
			and 
			let srcFMU = m.fmus(srcRef.name),
				trgRef = m.connections(srcRef) in 
				-- Every connection's destination is an input of its FMU
				(exists v in set srcFMU.outputs & srcRef.ref = v.ref)
				-- Every connection's destination is a known FMU
				and trgRef.name in set dom m.fmus
				and let trgFMU = m.fmus(trgRef.name) in 
					(exists v in set trgFMU.inputs & trgRef.ref = v.ref)
				and 
				let output = derefOutput(srcFMU, srcRef.ref),
					input = derefInput(trgFMU, trgRef.ref) in
				output.type = input.type
		)
		and
		(forall fmuref in set dom m.clockConnections &
			-- Every connection's source is a known FMU
			fmuref.name in set dom m.fmus
			-- Every connection's source is an output from its FMU
			and let fmu = m.fmus(fmuref.name) in
				exists v in set fmu.clocks & fmuref.ref = v.ref and v.type = <output>)
		and
		(forall fmuref in set rng m.clockConnections &
			-- Every connection's destination is a known FMU
			fmuref.name in set dom m.fmus
			-- Every connection's destination is an input of its FMU
			and let fmu = m.fmus(fmuref.name) in
				exists v in set fmu.clocks & fmuref.ref = v.ref and v.type = <input>)
		and dom m.clockConnections inter dom m.connections = {}
		and rng m.clockConnections inter rng m.connections = {};
  
	
functions
	/**
	 * These functions are total, because the error conditions that you would expect
	 * on an API are modelled by preconditions or type invariants.
	 */

	set_m: FMU * Ref * Value +> FMU
	set_m(fmu, ref, val) ==
		mu(fmu, env |-> fmu.env ++ { ref |-> val })
		-- and calculate equations?
	pre preSet(fmu, ref);

	get_m: FMU * Ref +> FMU * Value
	get_m(fmu, ref) ==
		-- calculate equations?
		mk_(fmu, fmu.env(ref))
	pre preGet(fmu, ref);

	set_cm: FMU * Ref * bool +> FMU
	set_cm(fmu, ref, val) ==
		mu(fmu,
			env				|-> fmu.env ++ {ref |-> mk_Value(val, fmu.time)},
			activeClocks	|-> if val then fmu.activeClocks union {ref} else fmu.activeClocks \ {ref})
	pre preSetC(fmu, ref, val)
	post val <=> ref in set fmu.activeClocks;

	get_cm: FMU * Ref +> FMU * Value
	get_cm(fmu, ref) ==
		mk_(fmu, fmu.env(ref))
	pre preGetC(fmu, ref);

	step_tm: FMU * real +> FMU * real * bool
	step_tm(fmu, step) ==
        let mk_(stepTaken, eventTriggered) = 
			if step >= fmu.maxStep then mk_(fmu.maxStep, true) else mk_(step, false)
		in
		mk_(mu(fmu, time |-> mk_Time(fmu.time.r + stepTaken, fmu.time.i)), stepTaken, eventTriggered)
	pre preStepT(fmu, step)
	post RESULT.#2 <= step -- We cannot take a step larger than what the Importer requested
        and RESULT.#2 <= fmu.maxStep; -- We cannot take a step larger than what the FMU is capable of
		
	step_e: FMU +> FMU * bool
	step_e(fmu) ==
		is not yet specified
	pre preStepE(fmu)
	post RESULT.#1.mode = <EVENT> 		-- FMU remains in event mode - it always does the Importer should bring it out
        and RESULT.#1.time.i = fmu.time.i + 1 -- The Integer component of the FMU should be increased
		and RESULT.#1.activeClocks = {} ; -- All clocks get disabled when we step the FMU

	/*
	 * 
	 */
	next_tm: FMU * Ref +> real | <NaN>
	next_tm(fmu, ref) ==
		is not yet specified
	pre exists v in set fmu.clocks & v.ref = ref
		and v.interval in set { <tunable>, <changing>, <countdown> };


	/**
	 * Dereference a clock in a given FMU.
	 */
	derefClock: FMU * Ref -> Clock
	derefClock(fmu, ref) ==
		iota c in set fmu.clocks & c.ref = ref
	pre exists c in set fmu.clocks & c.ref = ref;

	/**
	 * Dereference an input in a given FMU.
	 */
	derefInput: FMU * Ref -> Variable
	derefInput(fmu, ref) ==
		iota c in set fmu.inputs & c.ref = ref
	pre exists c in set fmu.inputs & c.ref = ref;

	/**
	 * Dereference an output in a given FMU.
	 */
	derefOutput: FMU * Ref -> Variable
	derefOutput(fmu, ref) ==
		iota c in set fmu.outputs & c.ref = ref
	pre exists c in set fmu.outputs & c.ref = ref;

	
	/*
	 * This function updates the Importer's environment according to observed clock value
	 */
	updateEnvironmentClock : Importer * FMU * Ref * bool -> Importer
	updateEnvironmentClock(I, fmu, clock, val)==
		let fmuref = mk_FMURef(fmu.name, clock),
			activatedVariables = createFMURefs(fmu, dunion {c.equations | c in set fmu.clocks & clock = c.ref}, {}) in
		mu(I,
			scenario |-> mu(I.scenario, fmus |-> I.scenario.fmus ++ {fmu.name |-> fmu}),
			activeClocks |-> if val then I.activeClocks union {fmuref} else I.activeClocks \ {fmuref},
			readyClocks |-> if val then I.readyClocks \ {fmuref} else I.readyClocks,
			inactiveClocks |-> if val then I.inactiveClocks \ {fmuref} else I.inactiveClocks union {fmuref},
			activeEquations |-> if val then I.activeEquations union activatedVariables else I.activeEquations \ activatedVariables,
			readyEquations |-> if val then I.readyEquations \ activatedVariables else I.readyEquations
		)
	pre let fmuRef = mk_FMURef(fmu.name,clock) in 
		fmuRef in set I.relevantInputClocks or fmuRef in set I.relevantOutputClocks;

	/*
	* Calculates an input equation that needs to be calculated
	* The port is calculated by the setting its value
	*/
	calculateInput : Importer * FMURef -> Importer
	calculateInput(I, equation)==
		let I1 = setPort(I, equation) in
			updateEnvironmentEquation(I1, I.scenario.fmus(equation.name), equation)
	pre 
		let fmu = I.scenario.fmus(equation.name) in
			equation in set I.activeEquations \ I.calculatedEquations -- The value should be active and not calculated before
			and equation in set dom I.valueMap -- A value to set should be accessible
			and fmu.mode = <EVENT>
			and (exists v in set fmu.inputs & v.ref = equation.ref and v.type = <discrete>); 

	/*
	* Calculates an output equation that needs to be calculated.
	* The port is calculated by the getting its value
	*/
	calculateOutput : Importer * FMURef -> Importer
	calculateOutput(I, equation)==
		let I1 = getPort(I, equation) in
			updateEnvironmentEquation(I1, I.scenario.fmus(equation.name), equation)
	pre 
		let fmu = I.scenario.fmus(equation.name) in
		equation in set I.activeEquations \ I.calculatedEquations
		and fmu.mode = <EVENT>
		and (exists v in set fmu.outputs & v.ref = equation.ref and v.type = <discrete>); 

	updateEnvironmentEquation : Importer * FMU * FMURef -> Importer
	updateEnvironmentEquation(I, fmu, equation)==
		let triggeredClocks = {clock | clock in set fmu.clocks & equation.ref in set clock.dependsOn} in
		-- We need to check if we triggered any clocks by setting the variable
		let triggeredInputs = {mk_FMURef(equation.name, inputClock.ref) | inputClock in set triggeredClocks & inputClock.type <> <input> },
			triggeredOutputs = {mk_FMURef(equation.name, outputClock.ref)  | outputClock in set triggeredClocks & outputClock.type <> <output> } in
		mu(I, 
			scenario |-> mu(I.scenario, fmus |-> I.scenario.fmus ++ {fmu.name |-> fmu}),
			calculatedEquations |-> I.calculatedEquations union {equation}, 
			relevantInputClocks |-> I.relevantInputClocks union triggeredInputs,
			relevantOutputClocks |-> I.relevantOutputClocks union triggeredOutputs
		)
	pre equation in set I.activeEquations \ I.calculatedEquations
	post equation in set RESULT.calculatedEquations;

    /*
		This function exchanges values between all connected Inputs and Outputs
		Currently we do not support algebraic loops
		It uses the runAlgorithm Function to execute the actions
	*/
    initializeData: Importer -> Importer
    initializeData(I) ==
	let connections = I.scenario.connections in
		let outputs = {mk_Action(<get>, output.name, output.ref) | output in set dom connections},
			inputs = {mk_Action(<set>, input.name, input.ref) | input in set rng connections} in
				runAlgorithm(I, outputs union inputs)
	pre 
	let fmus = rng I.scenario.fmus in
		assertFMUMode(fmus, {<INIT>})
		and fmusSynchronized(fmus)
	post 
	let fmus = rng RESULT.scenario.fmus in
		assertFMUMode(fmus, {<INIT>})
		and fmusSynchronized(fmus)
		and variablesSynchronized(RESULT.scenario);


	/*
		This function calculates the set of clocks that should be ticked
	 */
    tickingClocks: Importer -> Importer * set of FMURef
    tickingClocks(I) ==
		-- Clocks to tick at the current time
        let clocks = dom (I.schedule :> {I.time.r}) in
		-- Update the schedule for the ticked clocks to a new point in time
		--let updatedSchedule = clocks
		-- The clocks (input) are now relevant and their schedule is now updated
		let I1 = mu(I, relevantInputClocks |-> clocks) in --, schedule |-> updatedSchedule) in
		mk_(I1, clocks);


	/*
		This is the recurrence relation from the paper - calculating the set of FMUs that must enter Event mode.
		We added the FMUs that has a ticking clock 
		And subsequently include all FMUs that has clock connection from an FMU in the event Mode 
	 */ 
	calculateRelevantFMUs: Machine * set of Name * set of Name * set of FMURef -> set of Name 
	calculateRelevantFMUs(M, relevantFMUs, notRelevantFMUs, clocks) == 
		let addedFMUs = {clock.name | clock in set clocks} union
			{M.clockConnections(con).name | con in set dom M.clockConnections & con.name in set relevantFMUs 
														and M.clockConnections(con).name in set notRelevantFMUs} in
		-- We terminate if we have reached a fixed point where no more relevant FMUs can be found
		if addedFMUs = {} then relevantFMUs
		else 
			calculateRelevantFMUs(M, relevantFMUs union addedFMUs, notRelevantFMUs \ addedFMUs, clocks)
		pre relevantFMUs inter notRelevantFMUs = {}
		post {clock.name | clock in set clocks} subset RESULT 
			and RESULT subset dom M.fmus
			and 
				let notAdded = dom M.fmus \ RESULT in
					not exists srcClock in set dom M.clockConnections & srcClock.name in set RESULT and M.clockConnections(srcClock).name in set notAdded
		measure card notRelevantFMUs;

	/**
	 * Let M denote the set of FMU instances participating in the simulation. We
	 * assume that one FMU instance m in set M or the importer has requested to enter
	 * Event mode. Therefore we assume that every other instance m' in set M and m' <> m
	 * has been stepped up to the same super-dense time (t.r, 0).
	 */
	clockedSimulationAlgorithm: Importer * set of FMURef -> Importer
	clockedSimulationAlgorithm(I, clocks) ==
		/**
		 * 1. Every m in set M enters Event mode (super-dense time instant is t.i = 0);
		 */
		let relevantFMUs = calculateRelevantFMUs(I.scenario, I.fmusWithEvent, (dom I.scenario.fmus) \ I.fmusWithEvent, clocks) in
		let I1 = enterEventMode(I, relevantFMUs) in

		/**
		 * 2. Activate any time-based clocks scheduled to tick at (t.r , 0), by
		 *    invoking set_cm(_, wcm0) for any input or output clock wcm0 in set
		 *    Ucm union Ycm and any instance m in set M;
		 */

		let I2 = activateClocks(I1, clocks) in
		/*
			The event Iteration solves the system of equations, updates the schedule and the discrete state of the FMUs
		 */
		let I3 = eventIteration(I2, relevantFMUs) in

		/**
		 * 6. If any m in set M wishes to repeat the event iteration, or if a clock returned a
		 *    zero interval, go to Step 3 (start iteration t.i + 1).
		 */

		if I3.fmusWithEvent <> {} 
			then enterStepMode(I3, relevantFMUs)
		else clockedSimulationAlgorithm(I, clocks)

	pre 
		let fmus = rng I.scenario.fmus in
		fmusSynchronized(fmus)
		and assertFMUMode(fmus, {<STEP>})
		and (I.fmusWithEvent <> {} or clocks <> {}) -- An event is active
	post 		
		let fmus = rng RESULT.scenario.fmus in
		fmusSynchronized(fmus)
		and assertFMUMode(fmus, {<STEP>})
	-- I do not know the measure - it has something to do with the events that FMUs trigger
	measure is not yet specified;


eventIteration : Importer * set of Name -> Importer
eventIteration(I, relevantFMUs)==
		/**
		 * 3. Construct and solve system of equations for t.i :
		 * 		(a) For all ycm in set Ycm of any instance m in set M, forward activation state of
		 *		    triggered clocks:
		 * 			i. Invoke get_cm (_, ycm ), and set_cm(_, ucm0 ) or get_cm (_, ycm0 ),
		 *			   for any other clock ucm0 in set Ucm or ycm0 in set Ycm and instance
		 *			   m in set M that is transitively connected to ycm or has become active
		 *			   as a result of the clock activations;
		 *		(b) Invoke get_m(_, ym0) and set_m(_, um0, _) in the appropriate order,
		 *		    for any instance m in set M.
		 */

		let I1 = solveSystemOfEquations(I) in
		/**
		 * 4. Invoke step_e(_) for m in set M (signals end of Event iteration t.i).
		*/
		let I2 = updateDiscreteState(I1, relevantFMUs) in

		/**
			* 5. Schedule clocks by invoking next_tm on every relevant clock, for m in set M.
		*/
		updateSchedule(I2, relevantFMUs, { <tunable>, <changing>, <countdown> })
	pre 
		let fmus = rng (relevantFMUs <: I.scenario.fmus) in
		fmusSynchronized(fmus)
		and assertFMUMode(fmus, {<EVENT>})
	post 
		let newfmus = rng (relevantFMUs <: RESULT.scenario.fmus),
			oldfmus = rng (relevantFMUs <: I.scenario.fmus)
		in eventSolved(RESULT, newfmus, oldfmus);


/*
 * This function solves the active events by solving the system of equations
 * It terminates when all active variables have been calculated
 * Clock actions should also be performed before regular port actions.
 */
solveSystemOfEquations : Importer -> Importer
solveSystemOfEquations(I)==
	if I.activeEquations \ I.calculatedEquations = {} then I
	else
	let clockActions = { mk_Action(<setC>, clock.name, clock.ref) | clock in set I.relevantInputClocks }
						union { mk_Action(<getC>, clock.name, clock.ref) | clock in set I.relevantOutputClocks } in
		if clockActions <> {} and {a | a in set clockActions & isActionEnabled(I,a)} <> {} then
		   let clockAction in set {a | a in set clockActions & isActionEnabled(I, a)} in
				solveSystemOfEquations(runAction(I, clockAction))
		else
			let portActions = {mk_Action(<set>, input.name, input.ref) | input in set I.activeEquations \ I.calculatedEquations }
						union {mk_Action(<get>, output.name, output.ref) | output in set I.activeEquations \ I.calculatedEquations } in
				let portAction in set {a | a in set portActions & isActionEnabled(I, a)} in
					solveSystemOfEquations(runAction(I, portAction))
	post RESULT.activeEquations \ RESULT.calculatedEquations = {}
	measure card I.readyEquations + card (I.activeEquations \ I.calculatedEquations);


/*
	This function updates the schedule
*/
updateSchedule: Importer * set of Name * set of Interval -> Importer
updateSchedule(I, fmus, intervalSet)==
	if fmus = {} then I 
	else
	let name in set fmus in
		let fmu = I.scenario.fmus(name) in
			let relevantClocks = {c.ref | c in set fmu.clocks & c.interval in set intervalSet} in  
				let scheduleEntries = calculateSchedule(fmu, relevantClocks, {|->}) in
					let I1 = mu(I, schedule |-> I.schedule ++ scheduleEntries) in
						updateSchedule(I1, fmus \ {name}, intervalSet)
measure card fmus;

/*
	Calculate a schedule for all time based clocks
*/
createSchedule : Importer -> Importer
createSchedule(I) == 
	let fmus = dom I.scenario.fmus in 
		updateSchedule(I, fmus, {<constant>, <fixed>, <calculated>, <tunable>, <changing>, <countdown>})
pre 
	let fmus = rng I.scenario.fmus in
	assertFMUMode(fmus, {<INIT>})
	and fmusSynchronized(fmus)
	and variablesSynchronized(I.scenario)
post 
	let fmus = rng RESULT.scenario.fmus in
	let
	timeBasedClocks = dunion {createFMURefs(fmu, {clock.ref | clock in set fmu.clocks & clock.type = <input> and clock.interval <> <triggered>}, {}) | fmu in set fmus}
	in 
	dom RESULT.schedule = timeBasedClocks
	  -- all time-based clocks must have a schedule
	and assertFMUMode(fmus, {<INIT>})
	and fmusSynchronized(fmus)
	and variablesSynchronized(I.scenario);

calculateSchedule: FMU * set of Ref * map FMURef to real -> map FMURef to real
calculateSchedule(fmu, clocks, schedule)== 
	if clocks = {} then schedule
	else
	let clock in set clocks in
		let fmuRef = mk_FMURef(fmu.name, clock) in
		let S1 = schedule ++ {fmuRef |-> next_tm(fmu, clock)} in
		calculateSchedule(fmu, clocks \ {clock}, S1)
pre 
let cref = {c.ref | c in set fmu.clocks & c.type = <input> and c.interval <> <triggered> } in 
	clocks subset cref
measure card clocks; 

createFMURefs: FMU * set of Ref * set of FMURef -> set of FMURef
createFMURefs(fmu, clocks, res)==
	if clocks = {} then res
	else let clock in set clocks in
	createFMURefs(fmu, clocks \ {clock}, res union {mk_FMURef(fmu.name, clock)})
measure card clocks;