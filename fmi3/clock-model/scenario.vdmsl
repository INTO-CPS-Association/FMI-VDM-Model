functions
    createFMU : Name * set of Clock * set of Variable * set of Variable -> FMU
    createFMU(name, clocks, inputs, outputs) ==
            mk_FMU(
            name,
            clocks,
            inputs,
            outputs,
            <INIT>,
            mk_Time(0,0),
            false,
            5.0,
            -- I have added a default value
            { 10 |-> mk_Value(1,mk_Time(0,0))},
            {},
            {}
        );

    createVariable : Name * Ref * Causality * PortType * set of Ref * set of Ref * Contract-> Variable
    createVariable(name, ref, causality, type, clocks, dependsOn, contract) ==
        mk_Variable(name, ref, mk_Time(0,0), causality, type, clocks, dependsOn, contract);


    createClock : Name * Ref * Causality * Interval * set of Ref * set of Ref -> Clock
    createClock(name,ref, causality, interval, dependsOn, equations) ==
    	mk_Clock(name, ref, causality, interval, dependsOn, equations);

    createTimeBased : Name * real * real * Interval * FMURef -> TimeBasedClock 
    createTimeBased(name, shift, period, interval, master)==
        mk_TimeBasedClock(name, shift, period, interval, master);


    createScenario : () -> Machine
    createScenario() ==
        let ctrlInputs = {createVariable("a_s", 0, <input>, <discrete>, {}, {}, <delayed>),  createVariable("x_r",1, <input>, <discrete>, {}, {}, <delayed>)},
            ctrlOutputs = {createVariable("u_r", 10, <output>, <discrete>, {}, {}, <none>)},
            ctrlClocks = {createClock("s" ,20, <input>, <triggered>, {}, {0}), createClock("r", 21, <input>, <fixed>, {}, {1,10})} 
            in
        let ctrlFMU = createFMU("ctrl", ctrlClocks, ctrlInputs, ctrlOutputs) in

        let actuationInputs = {createVariable("u_r", 0, <input>, <discrete>, {}, {}, <delayed>)},
            actuationOutputs = {createVariable("u", 10, <output>, <continous>, {}, {}, <none>)},
            actuationClocks = {createClock("r", 20, <input>, <fixed>, {}, {0})} 
            in
        let actuationFMU = createFMU("actuation", actuationClocks, actuationInputs, actuationOutputs) in

        let plantInputs = {createVariable("u", 0, <input>, <continous>, {}, {}, <delayed>)},
            plantOutputs = {createVariable("x", 10, <output>, <continous>, {}, {}, <none>)},
            plantClocks = {} 
            in
        let plantFMU : FMU = createFMU("plant", plantClocks, plantInputs, plantOutputs) in
        
        let sensorInputs = {createVariable("x", 0, <input>, <continous>, {}, {}, <delayed>)},
            sensorOutputs = {createVariable("x_r",10, <output>, <discrete>, {}, {}, <none>)},
            sensorClocks = {createClock("r", 20, <input>, <fixed>, {}, {10})} 
            in
        let sensorFMU = createFMU("sensor", sensorClocks, sensorInputs, sensorOutputs) in


        let supervisorInputs = {},--{createVariable("x", 0, <input>, <continous>, {}, {}, <delayed>)},
            supervisorOutputs = {createVariable("a_s", 10, <output>, <discrete>, {}, {}, <none>)},
            supervisorClocks = {createClock("s",20, <output>, <triggered>, {}, {10})}
            in        
        let supervisorFMU = createFMU("supervisor", supervisorClocks, supervisorInputs, supervisorOutputs) in 

        let fmus = {fmu.name |-> fmu | fmu in set {sensorFMU, ctrlFMU, supervisorFMU, plantFMU, actuationFMU}} in

        let timeBasedClock_R = createTimeBased("r", 2, 2, <fixed>, mk_FMURef(ctrlFMU.name, 21)) in
        let timeBasedClocks = {timeBasedClock_R} in

        let connections = { mk_FMURef(supervisorFMU.name, 10) |-> mk_FMURef(ctrlFMU.name, 0),
                            mk_FMURef(ctrlFMU.name, 10) |-> mk_FMURef(actuationFMU.name, 0),
                            mk_FMURef(actuationFMU.name, 10) |-> mk_FMURef(plantFMU.name, 0),
                            mk_FMURef(plantFMU.name, 10) |-> mk_FMURef(sensorFMU.name, 0),
                            mk_FMURef(sensorFMU.name, 10) |-> mk_FMURef(ctrlFMU.name, 1)
                            },
            clockConnections = { mk_FMURef(supervisorFMU.name, 20) |-> mk_FMURef(ctrlFMU.name, 20)} 
        in
        let timeBasedClockConnections = {
            timeBasedClock_R.name |-> {mk_FMURef(sensorFMU.name, 20), mk_FMURef(actuationFMU.name, 20), mk_FMURef(ctrlFMU.name, 21)}
        } in

        mk_Machine(
            fmus, 
            timeBasedClocks, 
            connections, 
            clockConnections, 
            timeBasedClockConnections
        );

        


